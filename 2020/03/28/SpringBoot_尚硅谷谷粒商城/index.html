<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>谷粒商城项目学习笔记 | 梅罢葛的博客</title>
  <meta name="keywords" content=" java , SpringBoot , 分布式 , 后端 ">
  <meta name="description" content="谷粒商城项目学习笔记 | 梅罢葛的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="¶多主机如何共用一个IP地址？ NAT (Network Address Translator) 是一种用于将局域网中的私有地址转换成全局 IP 地址的技术。 在连接上无线路由器的时候，如果检查一下设备的 IP 地址，也许你会发现是类似于 192.168.1.1 这样的局域网 IP 地址。 下图描绘了 NAT 的工作原理： 局域网中 IP 地址为 10.0.0.10 的主机向全局 IP 地址 16">
<meta property="og:type" content="article">
<meta property="og:title" content="计网查漏补缺-网络层协议">
<meta property="og:url" content="https://qiurungeng.github.io/2020/11/04/%E8%AE%A1%E7%BD%91%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="梅罢葛的博客">
<meta property="og:description" content="¶多主机如何共用一个IP地址？ NAT (Network Address Translator) 是一种用于将局域网中的私有地址转换成全局 IP 地址的技术。 在连接上无线路由器的时候，如果检查一下设备的 IP 地址，也许你会发现是类似于 192.168.1.1 这样的局域网 IP 地址。 下图描绘了 NAT 的工作原理： 局域网中 IP 地址为 10.0.0.10 的主机向全局 IP 地址 16">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/image-20201104150027121.png">
<meta property="og:image" content="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/image-20201104145939691.png">
<meta property="article:published_time" content="2020-11-04T06:09:29.000Z">
<meta property="article:modified_time" content="2020-11-04T07:01:08.245Z">
<meta property="article:author" content="梅罢葛">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/image-20201104150027121.png">


<link rel="icon" href="/img/weini.png">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.webp" />
</a>
<div class="author">
    <span>梅罢葛</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/qiurungeng" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="email" href="mailto:708801794@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(54)</small></div></li>
    
        
            
            <li><div data-rel="Linux">Linux<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="前端">前端<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Java">Java<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(6)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Netty">Netty<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="SpringBoot">SpringBoot<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="spring">spring<small>(21)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据库">数据库<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="设计模式">设计模式<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="项目笔记">项目笔记<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="操作系统">操作系统<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="计算机网络">计算机网络<small>(3)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  site_url"  href="/about">关于</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="54">
<input type="hidden" id="yelog_site_word_count" value="74.4k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="Search..." />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color1">Linux</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">MySQL</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">前端</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">jvm</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">算法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">数据结构</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">socket编程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Netty</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">SpringBoot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">spring</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">spring注解</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">AOP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">spring-InstantiationAwareBeanPostProcessor</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">动态规划</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">LeetCode</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">剑指Offer</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">测试</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">操作系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">设计模式</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">NIO</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">分布式</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">后端</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">计算机网络</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="计算机网络 "
           href="/2020/11/04/%E8%AE%A1%E7%BD%91%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"
           data-tag="计算机网络"
           data-author="" >
            <span class="post-title" title="计网查漏补缺-网络层协议">计网查漏补缺-网络层协议</span>
            <span class="post-date" title="2020-11-04 14:09:29">2020/11/04</span>
        </a>
        
        <a  class="计算机网络 "
           href="/2020/11/04/%E8%AE%A1%E7%BD%91%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/"
           data-tag="计算机网络"
           data-author="" >
            <span class="post-title" title="计网查漏补缺-运输层协议">计网查漏补缺-运输层协议</span>
            <span class="post-date" title="2020-11-04 13:01:43">2020/11/04</span>
        </a>
        
        <a  class="计算机网络 "
           href="/2020/11/04/%E8%AE%A1%E7%BD%91%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"
           data-tag="计算机网络"
           data-author="" >
            <span class="post-title" title="计网查漏补缺-应用层协议">计网查漏补缺-应用层协议</span>
            <span class="post-date" title="2020-11-04 12:57:32">2020/11/04</span>
        </a>
        
        <a  class="Netty "
           href="/2020/10/27/Netty%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"
           data-tag="Netty"
           data-author="" >
            <span class="post-title" title="Netty入门案例">Netty入门案例</span>
            <span class="post-date" title="2020-10-27 20:28:27">2020/10/27</span>
        </a>
        
        <a  class="算法 "
           href="/2020/10/01/leetcode_LCP19%E7%A7%8B%E5%8F%B6%E6%94%B6%E8%97%8F%E9%9B%86/"
           data-tag="算法,LeetCode"
           data-author="" >
            <span class="post-title" title="LeetCode_LCP19秋叶收藏集">LeetCode_LCP19秋叶收藏集</span>
            <span class="post-date" title="2020-10-01 17:08:32">2020/10/01</span>
        </a>
        
        <a  class="操作系统 "
           href="/2020/09/06/CPU%E5%86%85%E5%AD%98%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%BC%93%E5%AD%98%E8%A1%8C/"
           data-tag="操作系统"
           data-author="" >
            <span class="post-title" title="CPU内存、缓存、缓存行">CPU内存、缓存、缓存行</span>
            <span class="post-date" title="2020-09-06 15:14:34">2020/09/06</span>
        </a>
        
        <a  class=""
           href="/2020/08/26/Netty%E5%AD%A6%E4%B9%A0-1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Netty学习-1">Netty学习-1</span>
            <span class="post-date" title="2020-08-26 21:30:22">2020/08/26</span>
        </a>
        
        <a  class=""
           href="/2020/08/26/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态规划-股票6">动态规划-股票6</span>
            <span class="post-date" title="2020-08-26 21:30:22">2020/08/26</span>
        </a>
        
        <a  class="算法 "
           href="/2020/06/25/%E5%89%91%E6%8C%87offer42%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"
           data-tag="算法,动态规划"
           data-author="" >
            <span class="post-title" title="剑指offer42：连续子数组的最大和">剑指offer42：连续子数组的最大和</span>
            <span class="post-date" title="2020-06-25 22:20:43">2020/06/25</span>
        </a>
        
        <a  class="算法 "
           href="/2020/06/25/%E5%89%91%E6%8C%87Offer60%20n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/"
           data-tag="算法,动态规划"
           data-author="" >
            <span class="post-title" title="剑指offer42：连续子数组的最大和">剑指offer42：连续子数组的最大和</span>
            <span class="post-date" title="2020-06-25 22:20:43">2020/06/25</span>
        </a>
        
        <a  class="Linux "
           href="/2020/05/13/%E8%A7%A3%E5%86%B3%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ASpringBoot%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%B7%A8%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"
           data-tag="Linux,SpringBoot"
           data-author="" >
            <span class="post-title" title="解决阿里云服务器上SpringBoot项目启动巨慢的问题">解决阿里云服务器上SpringBoot项目启动巨慢的问题</span>
            <span class="post-date" title="2020-05-13 15:52:04">2020/05/13</span>
        </a>
        
        <a  class="SpringBoot "
           href="/2020/05/06/SpringBoot%E8%A7%A3%E5%86%B3%E5%90%8E%E5%8F%B0%E8%BF%94%E5%9B%9EJSON%E5%88%B0%E5%89%8D%E7%AB%AF%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"
           data-tag="SpringBoot"
           data-author="" >
            <span class="post-title" title="SpringBoot解决后台返回JSON到前端出现中文乱码问题">SpringBoot解决后台返回JSON到前端出现中文乱码问题</span>
            <span class="post-date" title="2020-05-06 02:51:19">2020/05/06</span>
        </a>
        
        <a  class="Java "
           href="/2020/05/01/Jconsole%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"
           data-tag="Linux,java,jvm"
           data-author="" >
            <span class="post-title" title="Jconsole远程连接服务器">Jconsole远程连接服务器</span>
            <span class="post-date" title="2020-05-01 01:13:11">2020/05/01</span>
        </a>
        
        <a  class="前端 "
           href="/2020/04/28/Ajax%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/"
           data-tag="前端"
           data-author="" >
            <span class="post-title" title="Ajax提交form表单">Ajax提交form表单</span>
            <span class="post-date" title="2020-04-28 19:24:31">2020/04/28</span>
        </a>
        
        <a  class="前端 "
           href="/2020/04/28/Thymeleaf%E9%9A%8F%E6%89%8B%E8%AE%B0/"
           data-tag="前端,SpringBoot"
           data-author="" >
            <span class="post-title" title="Thymeleaf随手记">Thymeleaf随手记</span>
            <span class="post-date" title="2020-04-28 19:24:31">2020/04/28</span>
        </a>
        
        <a  class="SpringBoot "
           href="/2020/04/28/SpringBoot%E4%B8%ADCookie%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag="java,SpringBoot"
           data-author="" >
            <span class="post-title" title="SpringBoot中Cookie的使用">SpringBoot中Cookie的使用</span>
            <span class="post-date" title="2020-04-28 01:52:20">2020/04/28</span>
        </a>
        
        <a  class="SpringBoot "
           href="/2020/04/26/Spring%20Boot%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AF%BC%E8%87%B4%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E4%B9%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"
           data-tag="java,SpringBoot"
           data-author="" >
            <span class="post-title" title="Spring Boot静态资源无法访问之解决方案">Spring Boot静态资源无法访问之解决方案</span>
            <span class="post-date" title="2020-04-26 01:16:39">2020/04/26</span>
        </a>
        
        <a  class="算法 "
           href="/2020/04/21/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"
           data-tag="算法,LeetCode,剑指Offer"
           data-author="" >
            <span class="post-title" title="和为s的连续正数序列">和为s的连续正数序列</span>
            <span class="post-date" title="2020-04-21 12:53:58">2020/04/21</span>
        </a>
        
        <a  class="Netty "
           href="/2020/04/18/Netty%E6%A8%A1%E5%9E%8B/"
           data-tag="Netty"
           data-author="" >
            <span class="post-title" title="Netty模型">Netty模型</span>
            <span class="post-date" title="2020-04-18 18:01:43">2020/04/18</span>
        </a>
        
        <a  class="算法 "
           href="/2020/04/18/%E8%80%81%E9%BC%A0%E8%8D%AF/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="老鼠药">老鼠药</span>
            <span class="post-date" title="2020-04-18 17:08:32">2020/04/18</span>
        </a>
        
        <a  class="Netty "
           href="/2020/04/18/Reactor%E6%A8%A1%E5%BC%8F/"
           data-tag="Netty"
           data-author="" >
            <span class="post-title" title="Reactor模式">Reactor模式</span>
            <span class="post-date" title="2020-04-18 13:44:12">2020/04/18</span>
        </a>
        
        <a  class="Netty "
           href="/2020/04/18/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"
           data-tag="Netty"
           data-author="" >
            <span class="post-title" title="线程模型基本介绍">线程模型基本介绍</span>
            <span class="post-date" title="2020-04-18 13:09:51">2020/04/18</span>
        </a>
        
        <a  class="Linux "
           href="/2020/04/11/Linux%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"
           data-tag="Linux,操作系统"
           data-author="" >
            <span class="post-title" title="Linux网络IO模型">Linux网络IO模型</span>
            <span class="post-date" title="2020-04-11 04:45:19">2020/04/11</span>
        </a>
        
        <a  class="Java "
           href="/2020/04/11/Java-NIO%E5%85%A5%E9%97%A8/"
           data-tag="Java,NIO"
           data-author="" >
            <span class="post-title" title="Java NIO入门">Java NIO入门</span>
            <span class="post-date" title="2020-04-11 02:20:35">2020/04/11</span>
        </a>
        
        <a  class="Java "
           href="/2020/04/09/Java%E4%B8%8EC%E8%BF%9B%E8%A1%8CSocket%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9D%91/"
           data-tag="Java,socket编程"
           data-author="" >
            <span class="post-title" title="Java与C进行Socket通信的坑">Java与C进行Socket通信的坑</span>
            <span class="post-date" title="2020-04-09 04:22:15">2020/04/09</span>
        </a>
        
        <a  class="算法 "
           href="/2020/04/08/LRU%E7%AE%97%E6%B3%95/"
           data-tag="算法,数据结构"
           data-author="" >
            <span class="post-title" title="LRU算法">LRU算法</span>
            <span class="post-date" title="2020-04-08 22:14:01">2020/04/08</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/08/Spring%E6%89%A9%E5%B1%95%E5%8E%9F%E7%90%861-BeanFactoryPostProcessor/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring扩展原理1_BeanFactoryPostProcessor">Spring扩展原理1_BeanFactoryPostProcessor</span>
            <span class="post-date" title="2020-04-08 13:34:44">2020/04/08</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/07/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E5%A3%B0%E6%98%8E%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/"
           data-tag="java,spring,spring注解,spring-InstantiationAwareBeanPostProcessor"
           data-author="" >
            <span class="post-title" title="Spring注解学习_声明式事务原理">Spring注解学习_声明式事务原理</span>
            <span class="post-date" title="2020-04-07 23:28:49">2020/04/07</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/07/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_声明式事务">Spring注解学习_声明式事务</span>
            <span class="post-date" title="2020-04-07 21:02:02">2020/04/07</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/06/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-AOP%E5%8E%9F%E7%90%865-SpringAOP%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"
           data-tag="java,spring,spring注解,AOP"
           data-author="" >
            <span class="post-title" title="Spring注解学习_AOP原理5_SpringAOP总结">Spring注解学习_AOP原理5_SpringAOP总结</span>
            <span class="post-date" title="2020-04-06 22:32:08">2020/04/06</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/06/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-AOP%E5%8E%9F%E7%90%864-AopProxyFactory/"
           data-tag="java,spring,spring注解,AOP"
           data-author="" >
            <span class="post-title" title="Spring注解学习_AOP原理4_AopProxyFactory">Spring注解学习_AOP原理4_AopProxyFactory</span>
            <span class="post-date" title="2020-04-06 22:31:40">2020/04/06</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/06/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-AOP%E5%8E%9F%E7%90%863-AnnotationAwareAspectJAutoProxyCreator%E7%9A%84%E4%BD%9C%E7%94%A8/"
           data-tag="java,spring,spring注解,AOP"
           data-author="" >
            <span class="post-title" title="Spring注解学习_AOP原理3_AnnotationAwareAspectJAutoProxyCreator的作用">Spring注解学习_AOP原理3_AnnotationAwareAspectJAutoProxyCreator的作用</span>
            <span class="post-date" title="2020-04-06 22:30:57">2020/04/06</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/06/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-AOP%E5%8E%9F%E7%90%862-%E6%B3%A8%E5%86%8CAnnotationAwareAspectJAutoProxyCreator%E7%9A%84%E8%BF%87%E7%A8%8B/"
           data-tag="java,spring,spring注解,AOP"
           data-author="" >
            <span class="post-title" title="Spring注解学习_AOP原理2_注册AnnotationAwareAspectJAutoProxyCreator的过程">Spring注解学习_AOP原理2_注册AnnotationAwareAspectJAutoProxyCreator的过程</span>
            <span class="post-date" title="2020-04-06 22:30:25">2020/04/06</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/05/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-AOP%E5%8E%9F%E7%90%861-EnableAspectJAutoProxy/"
           data-tag="java,spring,spring注解,AOP,spring-InstantiationAwareBeanPostProcessor"
           data-author="" >
            <span class="post-title" title="Spring注解学习_AOP原理1_@EnableAspectJAutoProxy">Spring注解学习_AOP原理1_@EnableAspectJAutoProxy</span>
            <span class="post-date" title="2020-04-05 03:26:30">2020/04/05</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/03/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-AOP/"
           data-tag="java,spring,spring注解,AOP"
           data-author="" >
            <span class="post-title" title="Spring注解学习_AOP的注解方式实现">Spring注解学习_AOP的注解方式实现</span>
            <span class="post-date" title="2020-04-03 18:47:08">2020/04/03</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/03/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D4-Profile/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_自动装配4_@Profile">Spring注解学习_自动装配4_@Profile</span>
            <span class="post-date" title="2020-04-03 16:47:50">2020/04/03</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/03/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D3-Aware%E6%B3%A8%E5%85%A5Spring%E5%BA%95%E5%B1%82%E7%BB%84%E4%BB%B6-%E5%8E%9F%E7%90%86/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_自动装配3_Aware注入Spring底层组件&amp;原理">Spring注解学习_自动装配3_Aware注入Spring底层组件&amp;原理</span>
            <span class="post-date" title="2020-04-03 15:53:40">2020/04/03</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/03/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D2-Resource-Inject/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_自动装配2_@Resource&amp;@Inject">Spring注解学习_自动装配2_@Resource&amp;@Inject</span>
            <span class="post-date" title="2020-04-03 01:55:29">2020/04/03</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/03/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D1-Autowired-Qualifier-Primary/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_自动装配1_@Autowired&amp;@Qualifier&amp;@Primary">Spring注解学习_自动装配1_@Autowired&amp;@Qualifier&amp;@Primary</span>
            <span class="post-date" title="2020-04-03 00:06:03">2020/04/03</span>
        </a>
        
        <a  class="spring "
           href="/2020/04/02/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC-Value-PropertySource/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_属性赋值_@Value&amp;@PropertySource">Spring注解学习_属性赋值_@Value&amp;@PropertySource</span>
            <span class="post-date" title="2020-04-02 22:53:37">2020/04/02</span>
        </a>
        
        <a  class="spring "
           href="/2020/03/30/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2-BeanPostProcessor/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_生命周期2_BeanPostProcessor">Spring注解学习_生命周期2_BeanPostProcessor</span>
            <span class="post-date" title="2020-03-30 01:51:10">2020/03/30</span>
        </a>
        
        <a  class="spring "
           href="/2020/03/30/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_生命周期1_初始化和销毁方法">Spring注解学习_生命周期1_初始化和销毁方法</span>
            <span class="post-date" title="2020-03-30 00:23:45">2020/03/30</span>
        </a>
        
        <a  class="spring "
           href="/2020/03/29/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C-FactoryBean/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_组件注册5_FactoryBean">Spring注解学习_组件注册5_FactoryBean</span>
            <span class="post-date" title="2020-03-29 17:17:41">2020/03/29</span>
        </a>
        
        <a  class="spring "
           href="/2020/03/29/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C-Import/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_组件注册4_@Import">Spring注解学习_组件注册4_@Import</span>
            <span class="post-date" title="2020-03-29 15:33:06">2020/03/29</span>
        </a>
        
        <a  class="spring "
           href="/2020/03/29/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C-Condition/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_组件注册3_@Condition">Spring注解学习_组件注册3_@Condition</span>
            <span class="post-date" title="2020-03-29 14:52:02">2020/03/29</span>
        </a>
        
        <a  class="spring "
           href="/2020/03/29/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C-ComponentScan/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_组件注册2_@ComponentScan">Spring注解学习_组件注册2_@ComponentScan</span>
            <span class="post-date" title="2020-03-29 13:22:00">2020/03/29</span>
        </a>
        
        <a  class="spring "
           href="/2020/03/29/Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C-Configuration/"
           data-tag="java,spring,spring注解"
           data-author="" >
            <span class="post-title" title="Spring注解学习_组件注册1_@Configuration与@Bean">Spring注解学习_组件注册1_@Configuration与@Bean</span>
            <span class="post-date" title="2020-03-29 12:14:14">2020/03/29</span>
        </a>
        
        <a  class="Linux "
           href="/2020/03/28/CentOS%E5%AE%89%E8%A3%85Mysql/"
           data-tag="Linux,MySQL"
           data-author="" >
            <span class="post-title" title="CentOS安装及配置Mysql">CentOS安装及配置Mysql</span>
            <span class="post-date" title="2020-03-28 14:21:29">2020/03/28</span>
        </a>
        
        <a  class="设计模式 "
           href="/2020/03/28/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"
           data-tag="java,设计模式"
           data-author="" >
            <span class="post-title" title="工厂模式">工厂模式</span>
            <span class="post-date" title="2020-03-28 14:21:29">2020/03/28</span>
        </a>
        
        <a  class="SpringBoot "
           href="/2020/03/28/SpringBoot-debug%E7%90%90%E8%AE%B0/"
           data-tag="java,SpringBoot"
           data-author="" >
            <span class="post-title" title="SpringBoot-Debug持续记录">SpringBoot-Debug持续记录</span>
            <span class="post-date" title="2020-03-28 01:16:39">2020/03/28</span>
        </a>
        
        <a  class=""
           href="/2020/03/28/%E5%B0%9D%E8%AF%95%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/"
           data-tag="测试"
           data-author="" >
            <span class="post-title" title="尝试发布文章">尝试发布文章</span>
            <span class="post-date" title="2020-03-28 01:16:39">2020/03/28</span>
        </a>
        
        <a  class="数据库 "
           href="/2020/03/28/mysql%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0/"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="谷粒商城项目学习笔记：MySQL">谷粒商城项目学习笔记：MySQL</span>
            <span class="post-date" title="2020-03-28 01:16:39">2020/03/28</span>
        </a>
        
        <a  class="项目笔记 "
           href="/2020/03/28/SpringBoot_%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"
           data-tag="java,SpringBoot,分布式,后端"
           data-author="" >
            <span class="post-title" title="谷粒商城项目学习笔记">谷粒商城项目学习笔记</span>
            <span class="post-date" title="2020-03-28 01:16:39">2020/03/28</span>
        </a>
        
        <a  class=""
           href="/2020/03/27/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2020-03-27 22:09:17">2020/03/27</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-SpringBoot_尚硅谷谷粒商城" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">谷粒商城项目学习笔记</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="项目笔记">项目笔记</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color5">java</a>
            
            <a class="color1">SpringBoot</a>
            
            <a class="color4">分布式</a>
            
            <a class="color3">后端</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-04-26 23:34:35'>2020-03-28 01:16</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:29.4k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#P6-idea和git的配置"><span class="toc-text">P6 idea和git的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P12-通用Mapper的加入"><span class="toc-text">P12 通用Mapper的加入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p13"><span class="toc-text">p13</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P15-项目架构的介绍"><span class="toc-text">P15 项目架构的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#最终结构图："><span class="toc-text">最终结构图：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#抽取parent模块："><span class="toc-text">抽取parent模块：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#抽取API模块："><span class="toc-text">抽取API模块：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#抽取Utils模块："><span class="toc-text">抽取Utils模块：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P22-SOA面向服务（以Dubbo为基础）"><span class="toc-text">P22 SOA面向服务（以Dubbo为基础）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P23-启动-dubbo"><span class="toc-text">P23 启动 dubbo</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#启动监控中心："><span class="toc-text">启动监控中心：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#安装和配置zookeeper："><span class="toc-text">安装和配置zookeeper：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P27-将项目改造为Dubbo的分布式架构"><span class="toc-text">P27 将项目改造为Dubbo的分布式架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dubbo服务Provider的启动"><span class="toc-text">dubbo服务Provider的启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dubbo服务consumer的启动"><span class="toc-text">dubbo服务consumer的启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dubbo配置的注意事项："><span class="toc-text">dubbo配置的注意事项：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P30商品概念介绍"><span class="toc-text">P30商品概念介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pms商品的数据结构的划分"><span class="toc-text">pms商品的数据结构的划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#前端"><span class="toc-text">前端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解压前端项目gmall-admin"><span class="toc-text">解压前端项目gmall-admin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#用npm命令编译和启动前端的项目"><span class="toc-text">用npm命令编译和启动前端的项目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#前后端请求格式"><span class="toc-text">前后端请求格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P35-商城商品录入功能（Manage）"><span class="toc-text">P35 商城商品录入功能（Manage）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#实现manage-web模块"><span class="toc-text">实现manage-web模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#前后端的跨域问题"><span class="toc-text">前后端的跨域问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#商品平台属性的管理功能（增删改查）："><span class="toc-text">商品平台属性的管理功能（增删改查）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P43-商品SKU和SPU的概念、设计"><span class="toc-text">P43 商品SKU和SPU的概念、设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SPU的查询功能"><span class="toc-text">SPU的查询功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SPU添加功能"><span class="toc-text">SPU添加功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fastdfs分布式文件存储"><span class="toc-text">Fastdfs分布式文件存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#安装："><span class="toc-text">安装：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P53-开始安装"><span class="toc-text">P53 开始安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#测试图片："><span class="toc-text">测试图片：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Fdfs和SpringBoot整合"><span class="toc-text">Fdfs和SpringBoot整合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P67-SKU管理"><span class="toc-text">P67 SKU管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SKU表间的关联关系"><span class="toc-text">SKU表间的关联关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SKU的保存"><span class="toc-text">SKU的保存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P71-电商前台系统"><span class="toc-text">P71 电商前台系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Item商品详情-介绍"><span class="toc-text">1. Item商品详情 介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-前台系统中包含的业务功能"><span class="toc-text">2. 前台系统中包含的业务功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Item功能的创建"><span class="toc-text">3.Item功能的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-前台sku数据展示"><span class="toc-text">4.前台sku数据展示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-将后台查出的同属一个spu的sku与其sku销售属性的列表组合成一个静态的hash表"><span class="toc-text">5.将后台查出的同属一个spu的sku与其sku销售属性的列表组合成一个静态的hash表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-使用缓存redis解决页面并发问题"><span class="toc-text">6.使用缓存redis解决页面并发问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-redis的整合过程"><span class="toc-text">7.redis的整合过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-redis常见问题-注意事项"><span class="toc-text">8.redis常见问题&amp;注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-如何解决缓存击穿问题"><span class="toc-text">9. 如何解决缓存击穿问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P109-商城搜索：ElasticSearch"><span class="toc-text">P109 商城搜索：ElasticSearch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#介绍："><span class="toc-text">介绍：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-搜索引擎"><span class="toc-text">1. 搜索引擎</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-ES对中文的处理与解析："><span class="toc-text">4.ES对中文的处理与解析：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-ES的集群"><span class="toc-text">5.ES的集群</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-集群的工作原理"><span class="toc-text">6.集群的工作原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现："><span class="toc-text">实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-谷粒搜索模块"><span class="toc-text">7.谷粒搜索模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-通过ES的mapping定义商品的数据结构"><span class="toc-text">8. 通过ES的mapping定义商品的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-如何定义复杂查询"><span class="toc-text">9.如何定义复杂查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-前端静态资源"><span class="toc-text">10.前端静态资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-业务实现"><span class="toc-text">11.业务实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-搜索页面品台属性列表"><span class="toc-text">12.搜索页面品台属性列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-属性列表和面包屑的url"><span class="toc-text">13.属性列表和面包屑的url</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P153购物车"><span class="toc-text">P153购物车</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#谷粒购物车"><span class="toc-text">谷粒购物车</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-介绍"><span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-购物车添加商品功能"><span class="toc-text">2.购物车添加商品功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-购物车的缓存结构"><span class="toc-text">3.购物车的缓存结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-购物车列表"><span class="toc-text">4.购物车列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-代码实现："><span class="toc-text">5.代码实现：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#题外话——Dubbo服务端口绑定报错问题："><span class="toc-text">题外话——Dubbo服务端口绑定报错问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P167-用户认证Passport"><span class="toc-text">P167 用户认证Passport</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-介绍-v2"><span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-用户认证模块的设计："><span class="toc-text">2.用户认证模块的设计：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-认证中心"><span class="toc-text">3. 认证中心</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-单点登录（Single-Sign-On，SSO）"><span class="toc-text">4.单点登录（Single Sign On，SSO）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-用JWT实现用户登录的校验（token）"><span class="toc-text">5.用JWT实现用户登录的校验（token）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-passport登录功能"><span class="toc-text">6.passport登录功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-从首页点击登录的流程"><span class="toc-text">7.从首页点击登录的流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-拦截器开发"><span class="toc-text">8.拦截器开发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-用户UserService服务的对接"><span class="toc-text">9.用户UserService服务的对接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现："><span class="toc-text">代码实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P190-社交登录"><span class="toc-text">P190 社交登录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#四步完成授权操作："><span class="toc-text">四步完成授权操作：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#社交登录和项目的整合"><span class="toc-text">社交登录和项目的整合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现：-v2"><span class="toc-text">代码实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P203结算和订单"><span class="toc-text">P203结算和订单</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-介绍-v3"><span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-提交订单的业务"><span class="toc-text">2.提交订单的业务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-订单的安全"><span class="toc-text">3.订单的安全</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-订单数据的提交"><span class="toc-text">4.订单数据的提交</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P221支付服务"><span class="toc-text">P221支付服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#支付宝对接步骤"><span class="toc-text">支付宝对接步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#和支付宝建立支付协议（企业级账号）"><span class="toc-text">和支付宝建立支付协议（企业级账号）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#下载和整合支付宝sdk"><span class="toc-text">下载和整合支付宝sdk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#开发对接程序"><span class="toc-text">开发对接程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#完成对接的回调接口"><span class="toc-text">完成对接的回调接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如何验签："><span class="toc-text">如何验签：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P233分布式事务"><span class="toc-text">P233分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解决方案介绍："><span class="toc-text">解决方案介绍：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#消息队列中间件"><span class="toc-text">消息队列中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ActiveMQ的安装和整合"><span class="toc-text">ActiveMQ的安装和整合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#消息队列的模式"><span class="toc-text">消息队列的模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mq整合Spring"><span class="toc-text">mq整合Spring</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-分布式事务的业务模型"><span class="toc-text">5.分布式事务的业务模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P248延迟队列"><span class="toc-text">P248延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-延迟队列解决的问题"><span class="toc-text">1.延迟队列解决的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-消费延迟队列（支付服务）："><span class="toc-text">2. 消费延迟队列（支付服务）：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-幂等性问题"><span class="toc-text">3.幂等性问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-库存系统的介绍："><span class="toc-text">4. 库存系统的介绍：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P259基本完成，一些问题的补充"><span class="toc-text">P259基本完成，一些问题的补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P260秒杀和限流"><span class="toc-text">P260秒杀和限流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#秒杀"><span class="toc-text">秒杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#限流"><span class="toc-text">限流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot电商学习项目，教程视屏：<a href="https://www.bilibili.com/video/av55643074" target="_blank" rel="noopener">https://www.bilibili.com/video/av55643074</a></p>
<h3 id="P6-idea和git的配置"><a class="header-anchor" href="#P6-idea和git的配置">¶</a>P6 idea和git的配置</h3>
<p><strong>注意</strong>：项目开发协作时，git上不能提交[.idea]文件夹下的个人文件，否则会被队友打死</p>
<p>**Git上只应当提交：**1.源代码	2.pom依赖	3.配置文件</p>
<h3 id="P12-通用Mapper的加入"><a class="header-anchor" href="#P12-通用Mapper的加入">¶</a>P12 通用Mapper的加入</h3>
<p>1.在pom文件中引入通用Mapper依赖，此依赖可与已有MyBatis并存</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>2.在Mapper类中继承通用Mapper：tk.mybatis.mapper.common.Mapper</p>
<pre><code class="language-java">import tk.mybatis.mapper.common.Mapper;

public interface UserMapper extends Mapper&lt;UmsMember&gt; {
}
</code></pre>
<p>​	然后在ServiceImpl中就可调用通用mapper方法</p>
<pre><code class="language-java"> @Autowired
    UserMapper userMapper;

    @Override
    public List&lt;UmsMember&gt; getAllUser() {
        List&lt;UmsMember&gt; umsMemberList=userMapper.selectAll();
        return umsMemberList;
    }
</code></pre>
<p>3.配置通用Mapper的主键及主键返回策略</p>
<pre><code class="language-java">    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private String id;
</code></pre>
<p>4.配置启动类，使用tk.mybatis.spring.annotation.MapperScan扫描器</p>
<h3 id="p13"><a class="header-anchor" href="#p13">¶</a>p13</h3>
<p>**IDEA的Debug模式中：**F8——逐步执行，F9——跳过断点</p>
<p>通过bean中某一字段值查询的方法</p>
<p>1.用Bean对象查询</p>
<pre><code class="language-java">public List&lt;UmsMemberReceiveAddress&gt; getReceiveAddressByMemberId(String memberId) {
    UmsMemberReceiveAddress umsMemberReceiveAddress=new UmsMemberReceiveAddress();
    umsMemberReceiveAddress.setMemberId(memberId);

    List&lt;UmsMemberReceiveAddress&gt; umsMemberReceiveAddresses = userReceiveAddressMapper.select(umsMemberReceiveAddress);
    return umsMemberReceiveAddresses;
}
</code></pre>
<p>2.用Example对象查询</p>
<pre><code class="language-java">public List&lt;UmsMemberReceiveAddress&gt; getReceiveAddressByMemberId(String memberId) {
    Example example=new Example(UmsMemberReceiveAddress.class);
    example.createCriteria().andEqualTo(&quot;memberId&quot;,memberId);
    List&lt;UmsMemberReceiveAddress&gt; umsMemberReceiveAddresses = userReceiveAddressMapper.selectByExample(example);
    return umsMemberReceiveAddresses;
}
</code></pre>
<h3 id="P15-项目架构的介绍"><a class="header-anchor" href="#P15-项目架构的介绍">¶</a>P15 项目架构的介绍</h3>
<ol>
<li>
<p>工程结构</p>
<p>以maven为基础，对项目的分层架构</p>
</li>
<li>
<p>项目架构</p>
<p>分布式（SOA,Service Oriented Architecture）</p>
<h5 id="最终结构图："><a class="header-anchor" href="#最终结构图：">¶</a>最终结构图：</h5>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/1575097286710.png" alt="1575097286710"></p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/1575097118810.png" alt="1575097118810"></p>
<h5 id="抽取parent模块："><a class="header-anchor" href="#抽取parent模块：">¶</a>抽取parent模块：</h5>
<p>创建Maven Model，命名为gmall-parent，其中放置通用的pom依赖：</p>
<pre><code class="language-xml">    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.10.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;
    &lt;artifactId&gt;gmall-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
   &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;fastjson.version&gt;1.2.46&lt;/fastjson.version&gt;
        &lt;dubbo-starter.version&gt;1.0.10&lt;/dubbo-starter.version&gt;
        &lt;dubbo.version&gt;2.6.0&lt;/dubbo.version&gt;
        ······
    &lt;/properties&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
                &lt;version&gt;${fastjson.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
                &lt;version&gt;${dubbo.version}&lt;/version&gt;
            &lt;/dependency&gt;
            ······
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

</code></pre>
<p>在其他模块中引入parent模块：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;
        &lt;artifactId&gt;gmall-parent&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;
    &lt;artifactId&gt;gmall-user&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;gmall-user&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
</code></pre>
<h5 id="抽取API模块："><a class="header-anchor" href="#抽取API模块：">¶</a>抽取API模块：</h5>
<p>api模块：放置接口，bean文件，全都要用</p>
<p>（bean）</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/1575104420668.png" alt="1575104420668"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/1575104601010.png" alt="1575104601010"></p>
<p>（service）</p>
<h5 id="抽取Utils模块："><a class="header-anchor" href="#抽取Utils模块：">¶</a>抽取Utils模块：</h5>
<ol>
<li>Utils模块：项目中的通用框架，是所有应用工程需要引入的包（CommonUtil）</li>
</ol>
<blockquote>
<p>springboot、common-langs、common-beanutils……</p>
</blockquote>
<p>2.基于SOA的架构理念，项目分为web前端：controller（WebUtil）</p>
<blockquote>
<p>JSP、thymeleaf、cookie工具类……</p>
</blockquote>
<p>3.基于SOA的架构理念，项目分为web后端：service（ServiceUtil）</p>
<blockquote>
<p>MyBatis、mysql、redis……</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/1575117966350.png" alt="1575117966350"></p>
<p>controller = parent + api +webUtil</p>
<p>servive = parent + api + serviceUtil</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/1575122478336.png" alt=""></p>
<h3 id="P22-SOA面向服务（以Dubbo为基础）"><a class="header-anchor" href="#P22-SOA面向服务（以Dubbo为基础）">¶</a>P22 SOA面向服务（以Dubbo为基础）</h3>
<p>Dubbo通信时使用非Http协议（自定义协议），利用注册中心的客户端，通过Dubbo来访问服务。注册中心客户端负责实时同步注册中心的服务信息，Dubbo框架负责把服务封装成dubbo协议互相之间访问</p>
<p>1.Dubbo的工作原理和spring cloud类似</p>
<p>2.Dubbo和Spring Cloud的区别在于dubbo由自己的dubbo协议通信，而springcloud是由Http协议（Rest风格）</p>
<p>3.Dubbo有一个注册中心的客户端在实时同步注册中心的服务信息</p>
<p>4.Dubbo有一个javaweb的监控中心，负责监控服务的注册信息，甚至可以配置负载均衡</p>
<h3 id="P23-启动-dubbo"><a class="header-anchor" href="#P23-启动-dubbo">¶</a>P23 启动 dubbo</h3>
<h5 id="启动监控中心："><a class="header-anchor" href="#启动监控中心：">¶</a>启动监控中心：</h5>
<ol>
<li>将dubbo监控中心和tomcat上传到linux服务器</li>
<li>用unzip命令解压dubbo-admin.war</li>
<li>配置tomcat的server.xml，在末尾添加&lt;Context / &gt;：</li>
</ol>
<pre><code class="language-xml">&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
       prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
       pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;

&lt;Context path=&quot;/dubbo&quot; docBase=&quot;/opt/dubbo&quot; debug=&quot;0&quot; priviledged=&quot;true&quot; /&gt;

&lt;/Host&gt;
</code></pre>
<ol start="4">
<li>启动tomcat，打开监控中心。(本机浏览器访问linux ip地址时注意，须关掉linux防火墙)</li>
</ol>
<h5 id="安装和配置zookeeper："><a class="header-anchor" href="#安装和配置zookeeper：">¶</a>安装和配置zookeeper：</h5>
<ol>
<li>
<p>解压zookeeper，将zookeeper文件夹命名为zookeeper</p>
</li>
<li>
<p>修改zookeeper的配置文件（conf/zoo.cfg）</p>
<p>建立一个新的数据目录/opt/zookeeper/data</p>
<p>编辑conf/zoo.cfg,修改数据目录</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/1575259083061.png" alt="1575259083061"></p>
</li>
<li>
<p>启动zookeeper</p>
<pre><code class="language-sh">cd /opt/zookeeper/bin
</code></pre>
<pre><code class="language-shell">[root@localhost zookeeper]# cd bin
[root@localhost bin]# ./zkServer.sh start		主线程
ZooKeeper JMX enabled by default
Using config: /opt/zookeeper/bin/../conf/zoo.cfg
Starting zookeeper ... STARTED
[root@localhost bin]# ./zkServer.sh status		另外一线程
ZooKeeper JMX enabled by default
Using config: /opt/zookeeper/bin/../conf/zoo.cfg
Mode: standalone

</code></pre>
</li>
<li>
<p>设置监控中心和zookeeper的开机自启动：<br>
监控中心：</p>
<pre><code class="language-sh">cd /etc/init.d
</code></pre>
<pre><code class="language-sh">vim dubbo-admin
</code></pre>
<pre><code class="language-sh">#!/bin/bash
#chkconfig:2345 20 90
#description:dubbo-admin
#processname:dubbo-admin
CATALANA_HOME=/opt/tomcat
export JAVA_HOME=/usr/local/java/jdk1.8
case $1 in
start)  
    echo &quot;Starting Tomcat...&quot;  
    $CATALANA_HOME/bin/startup.sh  
    ;;  
  
stop)  
    echo &quot;Stopping Tomcat...&quot;  
    $CATALANA_HOME/bin/shutdown.sh  
    ;;  
  
restart)  
    echo &quot;Stopping Tomcat...&quot;  
    $CATALANA_HOME/bin/shutdown.sh  
    sleep 2  
    echo  
    echo &quot;Starting Tomcat...&quot;  
    $CATALANA_HOME/bin/startup.sh  
    ;;  
*)  
    echo &quot;Usage: tomcat {start|stop|restart}&quot;  
    ;; esac
</code></pre>
<pre><code class="language-sh">chkconfig --add dubbo-admin
</code></pre>
<pre><code class="language-sh">chmod 777 dubbo-admin
</code></pre>
<pre><code class="language-sh">service dubbo-admin start
</code></pre>
<p>​	zookeeper：</p>
<pre><code class="language-sh">cd /etc/init.d
</code></pre>
<pre><code class="language-sh">vim zookeeper
</code></pre>
<pre><code class="language-sh">#!/bin/bash
#chkconfig:2345 20 90
#description:zookeeper
#processname:zookeeper
ZK_PATH=/opt/zookeeper
export JAVA_HOME=/usr/local/java/jdk1.8
case $1 in
         start) sh  $ZK_PATH/bin/zkServer.sh start;;
         stop)  sh  $ZK_PATH/bin/zkServer.sh stop;;
         status) sh  $ZK_PATH/bin/zkServer.sh status;;
         restart) sh $ZK_PATH/bin/zkServer.sh restart;;
         *)  echo &quot;require start|stop|status|restart&quot;  ;;
esac
</code></pre>
<pre><code class="language-sh">chkconfig --add dubbo-admin
</code></pre>
<pre><code class="language-sh">chmod 777 dubbo-admin
</code></pre>
<pre><code class="language-sh">service dubbo-admin start
</code></pre>
</li>
</ol>
<h3 id="P27-将项目改造为Dubbo的分布式架构"><a class="header-anchor" href="#P27-将项目改造为Dubbo的分布式架构">¶</a>P27 将项目改造为Dubbo的分布式架构</h3>
<ol>
<li>
<p>将user项目拆分为user-servie和user-web</p>
</li>
<li>
<p>引入dubbo框架：</p>
<p>service层和web层都要用dubbo进行通信，故将dubbo引入到common-util中</p>
<p>注意到之前在gmall-parent的pom文件中已经定义好了依赖版本：</p>
<pre><code class="language-xml">    &lt;properties&gt;
        ......
        &lt;dubbo-starter.version&gt;1.0.10&lt;/dubbo-starter.version&gt;
        &lt;dubbo.version&gt;2.6.0&lt;/dubbo.version&gt;
        &lt;zkclient.version&gt;0.10&lt;/zkclient.version&gt;
        ......
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            ......
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
                &lt;version&gt;${dubbo.version}&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;com.101tec&lt;/groupId&gt;
                &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
                &lt;version&gt;${zkclient.version}&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;com.gitee.reger&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt;
                &lt;version&gt;${dubbo-starter.version}&lt;/version&gt;
            &lt;/dependency&gt;
            ......
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<p>然后在common-util中引入依赖:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.101tec&lt;/groupId&gt;
    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.gitee.reger&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>刷新maven依赖</li>
</ol>
</li>
</ol>
<h5 id="dubbo服务Provider的启动"><a class="header-anchor" href="#dubbo服务Provider的启动">¶</a>dubbo服务Provider的启动</h5>
<ol>
<li>
<p>将原项目的配置文件、serviceImpl与Mapper包复制到user-service模块中</p>
</li>
<li>
<p>修改user-service中的配置文件：</p>
</li>
</ol>
<pre><code class="language-properties"># 服务端口
server.port=8070
# jdbc配置
spring.datasource.username=root
spring.datasource.password=asdasdasd
spring.datasource.url=jdbc:mysql://localhost:3306/gmall?characterEncoding=UTF-8
# mybatis配置
mybatis.mapper-locations=classpath:mapper/*Mapper.xml
mybatis.configuration.map-underscore-to-camel-case=true

# dubbo的配置

# dubbo中的服务名称
spring.dubbo.application=user-service
# dubbo的通讯协议的名称
spring.dubbo.protocol.name=dubbo
# zookeeper注册中心的地址
spring.dubbo.registry.address=192.168.226.129:2181
# zookeeper的通讯协议的名称
spring.dubbo.registry.protocol=zookeeper
# dubbo的服务的扫描路径
spring.dubbo.base-package=com.atguigu.gmall
</code></pre>
<ol start="3">
<li>将Impl中的@Service所导入的包改为com.alibaba.dubbo.config.annotation.Service</li>
</ol>
<h5 id="dubbo服务consumer的启动"><a class="header-anchor" href="#dubbo服务consumer的启动">¶</a>dubbo服务consumer的启动</h5>
<ol>
<li>
<p>将原项目的配置文件、serviceImpl与Mapper包复制到user-web模块中</p>
</li>
<li>
<p>修改user-web中的配置文件：</p>
</li>
</ol>
<pre><code class="language-properties"># 服务端口
server.port=8080

# dubbo的配置

# dubbo中的服务名称
spring.dubbo.application=user-service
# dubbo的通讯协议的名称
spring.dubbo.protocol.name=dubbo
# zookeeper注册中心的地址
spring.dubbo.registry.address=192.168.226.129:2181
# zookeeper的通讯协议的名称
spring.dubbo.registry.protocol=zookeeper
# dubbo的服务的扫描路径
spring.dubbo.base-package=com.atguigu.gmall
# 设置超时时间(毫秒)
spring.dubbo.consumer.timeout=2000
</code></pre>
<ol start="3">
<li>将controller中的@Autowired改为@Reference</li>
</ol>
<h5 id="dubbo配置的注意事项："><a class="header-anchor" href="#dubbo配置的注意事项：">¶</a>dubbo配置的注意事项：</h5>
<ol>
<li>spring的@service改为dubbo的@Service</li>
<li>将@Autowired改为@Reference</li>
<li>dubbo在进行dubbo协议通讯时，要实现序列化接口（封装的数据对象）</li>
</ol>
<h3 id="P30商品概念介绍"><a class="header-anchor" href="#P30商品概念介绍">¶</a>P30商品概念介绍</h3>
<ol>
<li>
<p>系统名称：Gmall-Manager</p>
</li>
<li>
<p>数据结构：Pms、sku+spu</p>
<p>SKU：stock keeping unit 库存存储单元，一般指一个具体的库存商品，单位为台、部、件等</p>
<p>（比如某品牌鞋子的：款式+颜色+尺码就是这里说的SKU，是我们识别产品所必须的，也是商场进出存的最小单元*）</p>
<p>​	是库存进出计量的基本单元，是对大型连锁超市物流管理的一个必要方法。现在已经被引申为产品统一编号的建成。每一产品均只有对应的唯一的SKU号</p>
<p>SPU：standard product unit 标准的商品单元，一般一个商品（该商品又可分为XX系列），就是一个SPU。（比如IPhoneX就为一个SPU。由不同的颜色和内存大小，又可得到不同的SKU，如IPhoneX 64G 黑色）</p>
<p>​	是商品信息聚合的最小单元，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。</p>
<p>关系：</p>
<p>​	范围上来说Spu包含Sku</p>
<p>​	SPU表与SKU表是一对多的关系</p>
</li>
<li>
<p>平台属性：</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204161810546.png" alt="image-20191204161810546"></p>
<p>​	涉及的两张表pms_base_attr_info、pms_base_attr_value</p>
<h5 id="pms商品的数据结构的划分"><a class="header-anchor" href="#pms商品的数据结构的划分">¶</a>pms商品的数据结构的划分</h5>
<ol>
<li>sku的结构：pms_sku_</li>
<li>spu的结构：pms_spu_</li>
<li>类目的结构：pms_catalog</li>
<li>属性的结构：pms_attr_</li>
</ol>
<h5 id="前端"><a class="header-anchor" href="#前端">¶</a>前端</h5>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191203194941620.png" alt="image-20191203194941620"></p>
<p>模板技术：把页面中的静态数据替换成从后台数据库中的数据。这种操作用jsp就可以实现。但是Springboot 的架构不推荐使用Jsp，而且支持也不好，所以如果你是用springboot的话，一般使用Freemarker或者Thymeleaf。</p>
<p>前后端比较：</p>
<table>
<thead>
<tr>
<th>JVM</th>
<th>Spring</th>
<th>Maven</th>
<th>IDEA</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node.js</td>
<td>Vue</td>
<td>npm</td>
<td>vscode</td>
</tr>
</tbody>
</table>
<h5 id="解压前端项目gmall-admin"><a class="header-anchor" href="#解压前端项目gmall-admin">¶</a>解压前端项目gmall-admin</h5>
<p>解压后进入Conf文件夹，配置前端服务的IP 和 前端访问后端的数据服务服务的ip地址</p>
<p>dev.env.js 前端访问后端的数据服务的地址：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191203210301402.png" alt="image-20191203210301402"></p>
<p>index.js 前端的服务器的端口：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191203210542784.png" alt="image-20191203210542784"></p>
<h5 id="用npm命令编译和启动前端的项目"><a class="header-anchor" href="#用npm命令编译和启动前端的项目">¶</a>用npm命令编译和启动前端的项目</h5>
<p>在gmall-admin目录下执行命令：</p>
<pre><code class="language-bash">npm run dev
</code></pre>
<p>然后打开127.0.0.1:8888就可看到前端项目</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191203214955227.png" alt="image-20191203214955227"></p>
<h5 id="前后端请求格式"><a class="header-anchor" href="#前后端请求格式">¶</a>前后端请求格式</h5>
<p>一般前端会用post向后端发送请求（把参数封装到json中）</p>
<p>后端对应的<strong>请求格式：@RequestBody，返回格式：@ResponseBody</strong></p>
<h3 id="P35-商城商品录入功能（Manage）"><a class="header-anchor" href="#P35-商城商品录入功能（Manage）">¶</a>P35 商城商品录入功能（Manage）</h3>
<ol>
<li>
<p>三级分类的查询</p>
</li>
<li>
<p>商品的品台属性的增删改查</p>
</li>
<li>
<p>商品spu的添加</p>
<p>spu列表查询</p>
<p>spu的销售属性、属性值、Fastdfs图片上传</p>
</li>
<li>
<p>商品sku的添加</p>
<p>sku信息、sku关联的销售属性、sku关联的品台的属性、sku图片</p>
</li>
</ol>
<h5 id="实现manage-web模块"><a class="header-anchor" href="#实现manage-web模块">¶</a>实现manage-web模块</h5>
<p>商品分类功能查询：</p>
<ol>
<li>新建manage-web项目</li>
<li>配置pom</li>
<li>写一个getCatalog1()给前端项目调用</li>
<li>返回一个catalog1列表集合（json）</li>
<li>新建一个catalog服务接口</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191203231211803.png" alt="image-20191203231211803"></p>
<ol start="6">
<li>
<p>实现该服务</p>
<p>新建Mapper</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191203233024909.png" alt="image-20191203233024909"></p>
</li>
</ol>
<h5 id="前后端的跨域问题"><a class="header-anchor" href="#前后端的跨域问题">¶</a>前后端的跨域问题</h5>
<p>前端127.0.0.1:8888</p>
<p>后端127.0.0.1:8081</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204004733339.png" alt="image-20191204004733339"></p>
<p>前端和后端因为来自不同的网域，所以在http的安全协议策略下，不信任</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204004306304.png" alt="image-20191204004306304"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204004940481.png" alt="image-20191204004940481"></p>
<p>请求头、响应头都缺少：Access-Control-Allow-Origin</p>
<p><strong>解决方案</strong> ：</p>
<ol>
<li>前端加入请求头</li>
<li>后端Controller上加入@CrossOrigin跨域访问的注解</li>
</ol>
<p>成功：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204005916131.png" alt="image-20191204005916131"></p>
<h4 id="商品平台属性的管理功能（增删改查）："><a class="header-anchor" href="#商品平台属性的管理功能（增删改查）：">¶</a>商品平台属性的管理功能（增删改查）：</h4>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204161810546.png" alt="image-20191204161810546"></p>
<p>新建AttrController，AttrService，AttrServiceImpl及相应的Mapper，无太高技术含量，只记录一些要点。</p>
<p>Mapper.insert()与insertSelective()的区别：</p>
<table>
<thead>
<tr>
<th>insert</th>
<th>insertSelective</th>
</tr>
</thead>
<tbody>
<tr>
<td>会将null插入到数据库</td>
<td>null值不插入数据库</td>
</tr>
</tbody>
</table>
<p><strong>修改操作：</strong></p>
<p>先修改平台属性，再改属性值</p>
<p>进入修改页面时，注意到前端调用请求http://127.0.0.1:8081/getAttrValueList?attrId=43</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204210143068.png" alt="image-20191204210143068"></p>
<p>故实现getAttrValueList方法，为修改页面查询该平台属性的属性值值集合</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204210611056.png" alt="image-20191204210611056"></p>
<p>成功请求，可发现修改度逻辑为：查询+保存（该保存与新增操作区别在于属性值已有id）</p>
<pre><code class="language-java">String id=pmsBaseAttrInfo.getId();

if (StringUtils.isBlank(id)){
    //id为空时
    //保存属性
    pmsBaseAttrInfoMapper.insertSelective(pmsBaseAttrInfo);
    //保存属性值
    List&lt;PmsBaseAttrValue&gt; attrValueList = pmsBaseAttrInfo.getAttrValueList();
    for (PmsBaseAttrValue pmsBaseAttrValue : attrValueList) {
        pmsBaseAttrValue.setAttrId(pmsBaseAttrInfo.getId());
        pmsBaseAttrValueMapper.insertSelective(pmsBaseAttrValue);
    }
}else {
    //id不为空时，修改

    //属性修改
    Example example=new Example(PmsBaseAttrInfo.class);
    example.createCriteria().andEqualTo(&quot;id&quot;,id);
    pmsBaseAttrInfoMapper.updateByExampleSelective(pmsBaseAttrInfo,example);

    //属性值修改
    //按照属性ID删除所有属性值
    PmsBaseAttrValue pmsBaseAttrValueDel=new PmsBaseAttrValue();
    pmsBaseAttrValueDel.setAttrId(id);
    pmsBaseAttrValueMapper.delete(pmsBaseAttrValueDel);
	//删除后将新的属性值插入,若无新的属性值(全部删除)则将属性删除
    List&lt;PmsBaseAttrValue&gt; attrValueList=pmsBaseAttrInfo.getAttrValueList();
    if (attrValueList.isEmpty()){
        pmsBaseAttrInfoMapper.deleteByExample(example);
    }else {
        for (PmsBaseAttrValue pmsBaseAttrValue : attrValueList) {
            pmsBaseAttrValueMapper.insertSelective(pmsBaseAttrValue);
        }
    }
}
</code></pre>
<h3 id="P43-商品SKU和SPU的概念、设计"><a class="header-anchor" href="#P43-商品SKU和SPU的概念、设计">¶</a>P43 商品SKU和SPU的概念、设计</h3>
<p>商品模型设计：</p>
<ol>
<li>根据SKU、SPU电商模型设计</li>
<li>根据电商用户检索和过滤的需求</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204223134635.png" alt="image-20191204223134635"></p>
<h5 id="SPU的查询功能"><a class="header-anchor" href="#SPU的查询功能">¶</a>SPU的查询功能</h5>
<p>前台请求：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191204232402869.png" alt="image-20191204232402869"></p>
<p>仿照前面查询功能，返回PmsProductInfo列表即可。</p>
<h5 id="SPU添加功能"><a class="header-anchor" href="#SPU添加功能">¶</a>SPU添加功能</h5>
<ol>
<li>
<p>SPU信息：名称、描述</p>
</li>
<li>
<p>SPU图片信息：图片的对象数据保存在分布式的文件存储服务器上（fastdfs）、图片元数据保存在数据库</p>
</li>
</ol>
<ul>
<li>
<p>用户在选择完图片后，将图片在用户提交的时候和其他商品spu信息一起提交到后台</p>
</li>
<li>
<p>用户选择图片时就将图片上传到服务器（目前主流，可减轻服务器压力）</p>
</li>
</ul>
<ol start="3">
<li>SPU销售属性：</li>
</ol>
<p>​		对应的表：pms_product_sale_attr、pms_product_sale_attr_value</p>
<table>
<thead>
<tr>
<th>商品平台属性</th>
<th>商品销售属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>电商网站后台管理</td>
<td>由商家自行管理</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>
<p>销售属性字典表</p>
<p>商家在添加spu商品信息时，需要添加销售属性（自定义）</p>
<p>在添加spu页面，商家先选择销售属性（平台后台自定义的销售属性字典表），然后自定义当前的销售商品属性值。</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205010430860.png" alt="image-20191205010430860"></p>
</li>
</ol>
<p><strong>处理前台请求1，获取基本销售属性列表：</strong></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205010831635.png" alt="image-20191205010831635"></p>
<p>实现baseSaleAttrList查询，返回返回基本销售属性列表：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205012056878.png" alt="image-20191205012056878"></p>
<p><strong>处理前台请求2，保存PmsProductInfo：</strong></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205120525487.png" alt="image-20191205120525487"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205120628755.png" alt="image-20191205120628755"></p>
<p>所提供的的材料中,前后端对接参数名不一致,以下冲突采用前端参数命名：</p>
<table>
<thead>
<tr>
<th>前端</th>
<th>后端</th>
</tr>
</thead>
<tbody>
<tr>
<td>spuSaleAttrList</td>
<td>pmsProductSaleAttrList</td>
</tr>
<tr>
<td>spuSaleAttrValueList</td>
<td>pmsProductSaleAttrValueList</td>
</tr>
<tr>
<td>spuImageList</td>
<td>pmsProductImageList</td>
</tr>
</tbody>
</table>
<p><strong>处理前台请求3:，保存上传图片(fileUpload)：</strong></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205122952487.png" alt="image-20191205122952487"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205123214211.png" alt="image-20191205123214211"></p>
<p>用户点击上传图片后，后台将图片传到服务器上，然后返回图片的访问路径给前端。</p>
<p>用户点击保存时，将SPU基本信息、销售属性列表、图片地址列表等元数据保存到后台</p>
<h4 id="Fastdfs分布式文件存储"><a class="header-anchor" href="#Fastdfs分布式文件存储">¶</a>Fastdfs分布式文件存储</h4>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206001728209.png" alt="image-20191206001728209"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191207000126862.png" alt="image-20191207000126862"></p>
<p>Fastdfs：阿里，开源免费</p>
<p>本项目采用：Nginx+FastDFS</p>
<h5 id="安装："><a class="header-anchor" href="#安装：">¶</a>安装：</h5>
<ol start="0">
<li>
<p>安装前的准备：</p>
<p>yum install gcc-c++ -y</p>
<p>yum -y install zlib zlib-devel pcre pcre-devel gcc gcc-c++ openssl openssl-devel libevent libevent-devel perl unzip net-tools wget</p>
</li>
</ol>
<h5 id="P53-开始安装"><a class="header-anchor" href="#P53-开始安装">¶</a>P53 开始安装</h5>
<p>将fastdfs所有压缩包上载到服务器/opt目录</p>
<pre><code class="language-sh">chmod 777 *
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205170643455.png" alt="image-20191205170643455"></p>
<ol>
<li>
<p>fdfs依赖库：</p>
<p>Libfastcommon</p>
<p>a）解压安装压缩包</p>
<pre><code class="language-bash">[root@localhost opt]# tar -zxvf libfastcommonV1.0.7.tar.gz
</code></pre>
<p>b）/make.sh</p>
<pre><code class="language-bash">[root@localhost opt]# cd libfastcommon-1.0.7/
[root@localhost libfastcommon-1.0.7]# ./make.sh
</code></pre>
<p>c）/make.sh install</p>
<pre><code class="language-shell">[root@localhost libfastcommon-1.0.7]# ./make.sh install
</code></pre>
<p>d）用cp /usr/lib64/libfastcommon.so /usr/lib/ 将类库拷贝到/usr/lib目录</p>
<pre><code class="language-shell">[root@localhost libfastcommon-1.0.7]# cp /usr/lib64/libfastcommon.so /usr/lib/
</code></pre>
</li>
<li>
<p>fastdfs软件（tracker、storage）</p>
<p>作为练习项目，只安装在一台机器上</p>
<p>配置tracker</p>
<p>配置storage</p>
<p>(依赖于GCC、libevent、perl)</p>
<p>a）新建目录</p>
<pre><code class="language-shell">mkdir /opt/fastdfs
</code></pre>
<p>b）解压FastDFS压缩包到/usr/local</p>
<pre><code class="language-sh">
</code></pre>
<p>c）进入解压目录</p>
<pre><code class="language-sh">cd fastdfs
</code></pre>
<p>d）/make.sh</p>
<p>e）/make.sh install</p>
<p>f）进入conf配置文件目录将文件都拷贝到/etc/fdfs下</p>
<pre><code class="language-sh">cp * /etc/fdfs/
</code></pre>
<p>g）进入/etc/fdfs/，配置tracker.conf，设置软件的数据和目录</p>
<pre><code class="language-sh">vim /etc/fdfs/tracker.conf
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205173802270.png" alt="image-20191205173802270"></p>
<p>h）storage的配置（不用安装，因为安装tracker时已经同时安装了）</p>
<pre><code class="language-sh">vim /etc/fdfs/storage.conf
</code></pre>
<p>软件目录</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205174112279.png" alt="image-20191205174112279"></p>
<p>Storage存储文件的目录</p>
<pre><code class="language-sh">mkdir /opt/fastdfs/fdfs_storage 
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205174240918.png" alt="image-20191205174240918"></p>
<p>Storage的tracker的ip：改成本linux机的ip</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205174300669.png" alt="image-20191205174300669"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206151335305.png" alt="image-20191206151335305"></p>
</li>
<li>
<p>配置tracker和storage的启动服务</p>
<p><strong>tracker</strong>：</p>
<p>新建目录并将安装目录中的启动脚本复制到其中</p>
<pre><code class="language-sh">[root@localhost local]# cd /opt/FastDFS
[root@localhost FastDFS]# ls
client  COPYING-3_0.txt  init.d   php_client  stop.sh  tracker
common  fastdfs.spec     INSTALL  README.md   storage
conf    HISTORY          make.sh  restart.sh  test
[root@localhost FastDFS]# mkdir /usr/local/fdfs
[root@localhost FastDFS]# cp restart.sh /usr/local/fdfs/
[root@localhost FastDFS]# cp stop.sh /usr/local/fdfs/
</code></pre>
<p>修改启动脚本</p>
<pre><code class="language-sh">vim /etc/init.d/fdfs_trackerd
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205224341265.png" alt="image-20191205224341265"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205224401802.png" alt="image-20191205224401802"></p>
<p><strong>storage</strong>:</p>
<p>配置storage启动服务，由于restart个stop脚本已经复制到/usr/local/fdfs，所以storage只需要配置/etc/init.d/fdfs_storage脚本即可</p>
<pre><code class="language-sh">vim /etc/init.d/fdfs_storaged
</code></pre>
<p>修改处与fdfs_tracked相同</p>
<p><strong>注册服务</strong></p>
<pre><code class="language-sh">[root@localhost opt]# cd /etc/init.d
[root@localhost init.d]# chkconfig --add fdfs_trackerd 
[root@localhost init.d]# chkconfig --add fdfs_storaged
</code></pre>
<p>启动：</p>
<pre><code class="language-sh">[root@localhost init.d]# service fdfs_trackerd 
用法：/etc/init.d/fdfs_trackerd {start|stop|status|restart|condrestart}
[root@localhost init.d]# service fdfs_trackerd start
Starting fdfs_trackerd (via systemctl):                    [  确定  ]
[root@localhost init.d]# service fdfs_storaged start
Starting fdfs_storaged (via systemctl):                    [  确定  ]
</code></pre>
<p>显示成功启动：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205234514840.png" alt="image-20191205234514840"></p>
<h5 id="测试图片："><a class="header-anchor" href="#测试图片：">¶</a>测试图片：</h5>
<p>修改/etc/fdfs/client.conf</p>
<pre><code class="language-sh">vim /etc/fdfs/client.conf
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205234900214.png" alt="image-20191205234900214"></p>
<p>然后我们先在根目录放一张测试图片：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191205235625676.png" alt="image-20191205235625676"></p>
<p>上传：</p>
<pre><code class="language-sh">/usr/bin/fdfs_test  /etc/fdfs/client.conf  upload  /root/test_pic.jpg
</code></pre>
<p>上传成功后打印一堆日志信息，并有图片url</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206000025284.png" alt="image-20191206000025284"></p>
<p>图片路径：/opt/fastdfs/fdfs_storage/data/00/00</p>
<p>但此时无法访问改地址，由于没配置nginx</p>
</li>
<li>
<p>FastDFS-nginx-module</p>
<p>Fdfs整合nginx插件</p>
<p><strong>解压插件压缩包</strong></p>
<p>切换到/opt目录(压缩包所在目录)下</p>
<pre><code class="language-sh">tar -zxvf fastdfs-nginx-module_v1.16.tar.gz 
</code></pre>
<p><strong>修改插件读取fdfs的目录(插件自身的配置文件)</strong></p>
<pre><code class="language-sh">vim fastdfs-nginx-module/src/config
</code></pre>
<p>​	将下图所示红框处原先路径改为图中路径(/usr/local/include – usr/include)</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206005346033.png" alt="image-20191206005346033"></p>
<p><strong>将FastDFS-nginx-module插件整合fdfs的配置文件复制到fdfs配置目录下(整合fdfs的配置文件)</strong></p>
<pre><code class="language-sh">cp mod_fastdfs.conf /etc/fdfs/
</code></pre>
<pre><code class="language-sh">vim /etc/fdfs/mod_fastdfs.conf
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206010002903.png" alt="image-20191206010002903"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206010018674.png" alt="image-20191206010018674"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206010032556.png" alt="image-20191206010032556"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206010044410.png" alt="image-20191206010044410"></p>
</li>
<li>
<p>nginx</p>
<p>nginx作为web服务器，提供http请求服务</p>
<p>依赖：pcre-devel、zlib-devel</p>
<p><strong>解压安装压缩包</strong></p>
<p>cd /opt</p>
<pre><code class="language-sh">tar -zxvf nginx-1.12.2.tar.gz
</code></pre>
<pre><code class="language-sh">cd nginx-1.12.2
</code></pre>
<p>然后将下面命令复制到命令行执行：</p>
<pre><code class="language-sh">./configure \
--prefix=/usr/local/nginx \
--pid-path=/var/run/nginx/nginx.pid \
--lock-path=/var/lock/nginx.lock \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--with-http_gzip_static_module \
--http-client-body-temp-path=/var/temp/nginx/client \
--http-proxy-temp-path=/var/temp/nginx/proxy \
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
--http-scgi-temp-path=/var/temp/nginx/scgi \
--add-module=/opt/fastdfs-nginx-module/src
</code></pre>
<p>成功后将显示：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206011841082.png" alt="image-20191206011841082"></p>
<p>编译：</p>
<pre><code class="language-sh">make
</code></pre>
<p>安装：</p>
<pre><code class="language-sh">make install
</code></pre>
<p>编辑nginx.conf</p>
<pre><code class="language-sh">vim /usr/local/nginx/conf/nginx.conf
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191206012856282.png" alt="image-20191206012856282"></p>
<p>别忘了创建临时目录：/var/temp/nginx/client</p>
<pre><code class="language-sh">mkdir -p /var/temp/nginx/client
</code></pre>
<p>启动Nginx：</p>
<pre><code class="language-sh">cd /usr/local/nginx/sbin
</code></pre>
<pre><code class="language-sh">./nginx
</code></pre>
</li>
</ol>
<p>功能文件目录：</p>
<blockquote>
<p>Opt/fastdfs 软件数据存储目录</p>
<p>Usr/local/fdfs 启动文件目录</p>
<p>Etc/fdfs 配置文件目录</p>
<p>Usr/bin/fdfs_trackerd 启动配置</p>
<p>Etc/init.d/fdfs_trackerd 启动服务脚本</p>
</blockquote>
<h5 id="Fdfs和SpringBoot整合"><a class="header-anchor" href="#Fdfs和SpringBoot整合">¶</a>Fdfs和SpringBoot整合</h5>
<ol>
<li>从git上克隆fastdfs-client-java</li>
</ol>
<pre><code class="language-bash"> git clone https://github.com/happyfish100/fastdfs-client-java
</code></pre>
<ol start="2">
<li>
<p>将fdfs-client打包到本地maven仓库中</p>
<p>将克隆到本地的文件夹复制到项目目录下，单击选中，然后点击左上角&quot;file&quot;=&gt;“new”=&gt;“Module from …”</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191207003125526.png" alt="image-20191207003125526"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191207003032131.png" alt="image-20191207003032131"></p>
<p>然后一直下一步，将其设置为maven项目</p>
</li>
<li>
<p>maven install</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191207003530648.png" alt="image-20191207003530648"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191207003727962.png" alt="image-20191207003727962"></p>
</li>
<li>
<p>在common-util中引入已经打包好的maven依赖：</p>
<pre><code class="language-xml">&lt;!--引入FastDFS--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.csource&lt;/groupId&gt;
    &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;
    &lt;version&gt;1.27-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>manage-web模块下添加配置文件tracker.conf</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191207005651291.png" alt="image-20191207005651291"></p>
<pre><code class="language-conf">tracker_server=192.168.226.129:22122

# 连接超时时间，针对socket套接字函数connect，默认为30秒
connect_timeout=30000

# 网络通讯超时时间，默认是60秒
network_timeout=60000
</code></pre>
</li>
<li>
<p>运行如下测试代码:</p>
<pre><code class="language-java">@Test
public void textFileUpload() throws IOException, MyException {
    //配置fdfs的全局链接地址
    String file = this.getClass().getResource(&quot;/tracker.conf&quot;).getFile();
    ClientGlobal.init(file);
    TrackerClient trackerClient=new TrackerClient();
    //获得一个trackerServer实例
    TrackerServer trackerServer=trackerClient.getConnection();
    //通过tracker获得一个storage的链接客户端
    StorageClient storageClient=new StorageClient(trackerServer,null);
    //上传图片
    String orginalFilename=&quot;C:\\Users\\Apollos\\Desktop\\文史研究\\timg.jpg&quot;;
    String[] upload_file = storageClient.upload_file(orginalFilename, &quot;jpg&quot;, null);
    //打印返回信息
    for (int i = 0; i &lt; upload_file.length; i++) {
        String s = upload_file[i];
        System.out.println(&quot;s = &quot; + s);
    }
}
</code></pre>
<p>成功：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191207011343367.png" alt="image-20191207011343367"></p>
</li>
</ol>
<h3 id="P67-SKU管理"><a class="header-anchor" href="#P67-SKU管理">¶</a>P67 SKU管理</h3>
<h5 id="SKU表间的关联关系"><a class="header-anchor" href="#SKU表间的关联关系">¶</a>SKU表间的关联关系</h5>
<ul>
<li>pms_sku_info</li>
</ul>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191222223807029.png" alt="image-20191222223807029"></p>
<ul>
<li>pms_sku_attr_value（attr_id：对应的平台属性id，value_id：对应的平台属性值的id）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191222224613436.png" alt="image-20191222224613436"></p>
<ul>
<li><code>pms_base_attr_info</code>平台属性表</li>
</ul>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191222224712039.png" alt="image-20191222224712039"></p>
<ul>
<li>pms_base_attr_value平台属性值表</li>
</ul>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191222224805720.png" alt="image-20191222224805720"></p>
<p>pms_sku_img(从已添加的spu图片中选取，当前sku涉及的图片：比如，IPhoneX spu图片30张 ，其中包含 IPhoneX黑色 sku图片7张)</p>
<h5 id="SKU的保存"><a class="header-anchor" href="#SKU的保存">¶</a>SKU的保存</h5>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191222231154470.png" alt=""></p>
<p>点击进入添加sku页面后，我么发现：</p>
<ol>
<li>
<p>已有attrInfoList方法，但返回的BaseAttrInfo中没有pmsBaseAttrValueList</p>
<p>在其serviceImpl中完善一下:</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191222231444755.png" alt="image-20191222231444755"></p>
<pre><code class="language-java">@Override
public List&lt;PmsBaseAttrInfo&gt; attrInfoList(String catalog3Id) {
    PmsBaseAttrInfo pmsBaseAttrInfo=new PmsBaseAttrInfo();
    pmsBaseAttrInfo.setCatalog3Id(catalog3Id);
    List&lt;PmsBaseAttrInfo&gt; pmsBaseAttrInfos = pmsBaseAttrInfoMapper.select(pmsBaseAttrInfo);
    for (PmsBaseAttrInfo baseAttrInfo : pmsBaseAttrInfos) {

        List&lt;PmsBaseAttrValue&gt; pmsBaseAttrValues;
        PmsBaseAttrValue pmsBaseAttrValue=new PmsBaseAttrValue();
        pmsBaseAttrValue.setAttrId(baseAttrInfo.getId());
        pmsBaseAttrValues=pmsBaseAttrValueMapper.select(pmsBaseAttrValue);

        baseAttrInfo.setAttrValueList(pmsBaseAttrValues);
    }
    return pmsBaseAttrInfos;
}
</code></pre>
<p>然后可以看见，平台属性被添加上来了:</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191223114310890.png" alt="image-20191223114310890"></p>
</li>
<li>
<p>未实现方法:</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191222231444755.png" alt=""></p>
<blockquote>
<p>请求销售属性列表：<a href="http://127.0.0.1:8081/spuSaleAttrList?spuId=24" target="_blank" rel="noopener">http://127.0.0.1:8081/spuSaleAttrList?spuId=24</a></p>
<p>请求spu图片列表:<a href="http://127.0.0.1:8081/spuImageList?spuId=24" target="_blank" rel="noopener">http://127.0.0.1:8081/spuImageList?spuId=24</a></p>
</blockquote>
<p>依次实现，较为简单不做赘述</p>
<p>保存：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20191223003155098.png" alt=""></p>
</li>
</ol>
<blockquote>
<p>保存sku:<a href="http://127.0.0.1:8081/spuImageList?spuId=24" target="_blank" rel="noopener">http://127.0.0.1:8081/spuImageList?spuId=24</a></p>
</blockquote>
<p>​	为sku添加controller及service</p>
<p>​	注意：此项目前后端部分字段对不上，我们改后端，折中处理</p>
<p>​	bean:</p>
<pre><code class="language-java">public class PmsSkuInfo implements Serializable {

    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Id
    @Column
    String id;

    @Column
    String productId;

    @Transient
    String spuId;	//临时字段
</code></pre>
<p>​	controller:</p>
<pre><code class="language-java">@RequestMapping(&quot;saveSkuInfo&quot;)
@ResponseBody
public String saveSkuInfo(@RequestBody PmsSkuInfo pmsSkuInfo){
    //前后端属性名对不上，故将前端spuId赋值给productId
    pmsSkuInfo.setProductId(pmsSkuInfo.getSpuId());
    //前端没有默认图片校验，我们加上验证
    String skuDefaultImg=pmsSkuInfo.getSkuDefaultImg();
    if (StringUtils.isBlank(skuDefaultImg)){
        pmsSkuInfo.setSkuDefaultImg(pmsSkuInfo.getPmsSkuImageList().get(0).getImgUrl());
    }

    skuService.saveSkuInfo(pmsSkuInfo);
    return &quot;success&quot;;
}
</code></pre>
<p>service:</p>
<pre><code class="language-java">@Service
public class SkuServiceImpl implements SkuService {
    @Autowired
    PmsSkuInfoMapper pmsSkuInfoMapper;
    @Autowired
    PmsSkuAttrValueMapper pmsSkuAttrValueMapper;
    @Autowired
    PmsSkuSaleAttrValueMapper pmsSkuSaleAttrValueMapper;
    @Autowired
    PmsSkuImageMapper pmsSkuImageMapper;

    @Override
    public void saveSkuInfo(PmsSkuInfo pmsSkuInfo) {
        //插入skuInfo
        int i = pmsSkuInfoMapper.insertSelective(pmsSkuInfo);
        String skuId=pmsSkuInfo.getId();

        // 插入平台属性关联
        List&lt;PmsSkuAttrValue&gt; skuAttrValueList = pmsSkuInfo.getSkuAttrValueList();
        for (PmsSkuAttrValue pmsSkuAttrValue : skuAttrValueList) {
            pmsSkuAttrValue.setSkuId(skuId);
            pmsSkuAttrValueMapper.insertSelective(pmsSkuAttrValue);
        }

        // 插入销售属性关联
        List&lt;PmsSkuSaleAttrValue&gt; skuSaleAttrValueList = pmsSkuInfo.getSkuSaleAttrValueList();
        for (PmsSkuSaleAttrValue pmsSkuSaleAttrValue : skuSaleAttrValueList) {
            pmsSkuSaleAttrValue.setSkuId(skuId);
            pmsSkuSaleAttrValueMapper.insertSelective(pmsSkuSaleAttrValue);
        }

        // 插入图片信息
        List&lt;PmsSkuImage&gt; skuImageList = pmsSkuInfo.getSkuImageList();
        for (PmsSkuImage pmsSkuImage : skuImageList) {
            pmsSkuImage.setSkuId(skuId);
            pmsSkuImageMapper.insertSelective(pmsSkuImage);
        }
    }
}
</code></pre>
<h3 id="P71-电商前台系统"><a class="header-anchor" href="#P71-电商前台系统">¶</a>P71 电商前台系统</h3>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200122191846858.png" alt="image-20200122191846858"></p>
<h5 id="1-Item商品详情-介绍"><a class="header-anchor" href="#1-Item商品详情-介绍">¶</a>1. Item商品详情 介绍</h5>
<p>电商前台页面是给消费者用户看的，前台系统压力更大，多用缓存、负载均衡，注意数据的一致性	<br>
后台页面是给管理人员或商家看的。压力小，直连数据库，注意数据的一致性<br>
前台后台联系：数据结构是同一套，后台系统的一些设置可以控制前台系统的运行方式</p>
<h5 id="2-前台系统中包含的业务功能"><a class="header-anchor" href="#2-前台系统中包含的业务功能">¶</a>2. 前台系统中包含的业务功能</h5>
<p>首页（静态化）<br>
检索页（搜索引擎）<br>
详情页（缓存、切换、推荐）<br>
购物车页（cookie、redis）<br>
结算页（一致性校验、安全）<br>
支付页</p>
<h5 id="3-Item功能的创建"><a class="header-anchor" href="#3-Item功能的创建">¶</a>3.Item功能的创建</h5>
<p>创建一个item-web的商品详情工程<br>
配置item-web，pom，properties<br>
引入thymeleaf依赖</p>
<pre><code class="language-html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
</code></pre>
<p><strong>设置热部署，松校验</strong></p>
<p>gmall-web-util模块下的pom.xml:</p>
<pre><code class="language-xml">&lt;!--thymeleaf支持包，可以设置松校验、热部署--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;
    &lt;artifactId&gt;nekohtml&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;xml-apis&lt;/groupId&gt;
    &lt;artifactId&gt;xml-apis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt;
    &lt;artifactId&gt;batik-ext&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>gmall-item-web模块下的properties文件:</p>
<pre><code class="language-properties"># 关闭thymeleaf的缓存(热部署)
spring.thymeleaf.cache=false
# 松校验
spring.thymeleaf.mode=LEGACYHTML5
</code></pre>
<h5 id="4-前台sku数据展示"><a class="header-anchor" href="#4-前台sku数据展示">¶</a>4.前台sku数据展示</h5>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200205045124458.png" alt="image-20200205045124458"></p>
<p>引入商品详情前端静态资源。</p>
<p>查看item.html中需要后端传入的值，做好前后端对接：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200205045316903.png" alt="image-20200205045316903"></p>
<p>包括：skuInfo、skuImage、spuSaleAttr、saleAttrValue等</p>
<p><strong>sku根据销售属性动态切换</strong></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200206042503842.png" alt="image-20200206042503842"></p>
<ol>
<li>
<p>数据模型（根据销售属性切换一个sku的其他兄弟姐妹）</p>
<p>pms_sku_info、pms_sku_image<br>
pms_sku_sale_attr_value<br>
pms_sale_attr<br>
pms_spu_sale_attr_value</p>
</li>
<li>
<p>如何实现这些数据模型对应的业务功能</p>
<p>A）页面根据销售属性列表(当前sku对应的spu的id)</p>
<p>​	pms_spu_sale_attr<br>
​	pms_product_sale_attr</p>
<pre><code class="language-mysql">select * from
	pms_product_sale_attr sa,
	pms_product_sale_attr_value sav
where
	sa.product_id=sav.product_id
and sa.sale_attr_id=sav.sale_attr_id
and sa.product_id=?
</code></pre>
<p>B）页面根据销售属性的选择的组合，定位到关联的sku</p>
<p>​	通过页面被选中属性值的id查询中间表：pms_sku_sale_attr_value得到skuId</p>
<pre><code class="language-sql">SELECT sku_id FROM
	pms_sku_sale_attr_value ssav
WHERE 
	ssav.sale_attr_id IN (?,?)      # 销售属性id1，销售属性id2
AND ssav.sale_attr_value_id IN (?,?)
</code></pre>
<p>C）根据skuId查询到sku对象，返回到页面</p>
<p>ABC:这样做的坏处是一共要向后台发送两次查询请求，极度低效</p>
<p>D）功能优化：</p>
<p>在用户进入某一个spu领域后，将该spu所包含的sku们和这些对应的销售属性值生成一个键值对（key为销售属性值的组合，value为skuid）hash表格，放到页面上</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200206053013430.png" alt="image-20200206053013430"></p>
<p>在用户选择完销售属性后，根据hash组合找到对应的skuId</p>
<p>升级后的查询SQL:</p>
<pre><code class="language-sql">SELECT
	sa.*,sav.*,if(ssav.sku_id,1,0) as isChecked
FROM
	pms_product_sale_attr sa
	INNER JOIN pms_product_sale_attr_value sav ON sa.product_id = sav.product_id 
	AND sa.sale_attr_id = sav.sale_attr_id 
	AND sa.product_id = ?
	LEFT JOIN pms_sku_sale_attr_value ssav ON sav.id = ssav.sale_attr_value_id 
	AND ssav.sku_id = ?
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200210080732579.png" alt="image-20200210080732579"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200210080808639.png" alt="image-20200210080808639"></p>
<p><strong>实现：</strong></p>
<p>ItemController:</p>
<pre><code class="language-java">@RequestMapping(&quot;{skuId}.html&quot;)
public String item(@PathVariable String skuId, ModelMap map){
    //sku对象
    PmsSkuInfo skuInfo=skuService.getSkuById(skuId);
    map.put(&quot;skuInfo&quot;,skuInfo);
    //销售属性列表
    List&lt;PmsProductSaleAttr&gt; pmsProductSaleAttrs=spuService.spuSaleAttrListCheckBySku(skuInfo.getProductId(),skuId);
    map.put(&quot;spuSaleAttrListCheckBySku&quot;,pmsProductSaleAttrs);
    return &quot;item&quot;;
}
</code></pre>
<p>SpuService:</p>
<pre><code class="language-java">List&lt;PmsProductSaleAttr&gt; spuSaleAttrListCheckBySku(String productId,String skuId);
</code></pre>
<p>SpuServiceImpl:</p>
<pre><code class="language-java">@Override
public List&lt;PmsProductSaleAttr&gt; spuSaleAttrListCheckBySku(String productId,String skuId) {
    List&lt;PmsProductSaleAttr&gt; pmsProductSaleAttrs = pmsProductSaleAttrMapper.selectSpuSaleAttrListCheckBySku(productId,skuId);
    return pmsProductSaleAttrs;
}
</code></pre>
<p>PmsProductSaleAttrMapper:</p>
<pre><code class="language-java">public interface PmsProductSaleAttrMapper extends Mapper&lt;PmsProductSaleAttr&gt; {
    List&lt;PmsProductSaleAttr&gt; selectSpuSaleAttrListCheckBySku(@Param(&quot;productId&quot;) String productId, @Param(&quot;skuId&quot;) String skuId);
}
</code></pre>
<p>gmall-manage-service的resources下的mapper文件夹中，PmsProductSaleAttrMapper.xml:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.atguigu.gmall.manage.mapper.PmsProductSaleAttrMapper&quot;&gt;
    &lt;select id=&quot;selectSpuSaleAttrListCheckBySku&quot; resultMap=&quot;selectSpuSaleAttrListCheckBySkuMap&quot;&gt;
        SELECT
            sa.id as sa_id,sav.id as sav_id,sa.*,sav.*,if(ssav.sku_id,1,0) as isChecked
        FROM
            pms_product_sale_attr sa
            INNER JOIN pms_product_sale_attr_value sav ON sa.product_id = sav.product_id
            AND sa.sale_attr_id = sav.sale_attr_id
            AND sa.product_id = #{productId}
            LEFT JOIN pms_sku_sale_attr_value ssav ON sav.id = ssav.sale_attr_value_id
            AND ssav.sku_id = #{skuId}
    &lt;/select&gt;
    
    &lt;resultMap id=&quot;selectSpuSaleAttrListCheckBySkuMap&quot; type=&quot;com.atguigu.gmall.bean.PmsProductSaleAttr&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;sa_id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;spuSaleAttrValueList&quot; ofType=&quot;com.atguigu.gmall.bean.PmsProductSaleAttrValue&quot; autoMapping=&quot;true&quot;&gt;
            &lt;result column=&quot;sav_id&quot; property=&quot;id&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ol>
<h5 id="5-将后台查出的同属一个spu的sku与其sku销售属性的列表组合成一个静态的hash表"><a class="header-anchor" href="#5-将后台查出的同属一个spu的sku与其sku销售属性的列表组合成一个静态的hash表">¶</a>5.将后台查出的同属一个spu的sku与其sku销售属性的列表组合成一个静态的hash表</h5>
<ol>
<li>sql查询出sku和关联的销售属性</li>
</ol>
<pre><code class="language-sql">SELECT
	si.id,
	ssav.sale_attr_value_id 
FROM
	pms_sku_info si,
	pms_sku_sale_attr_value ssav 
WHERE
	si.product_id = 74 
	AND si.id = ssav.sku_id;
</code></pre>
<ol start="2">
<li>
<p>实现：</p>
<p>ItemControlelr:</p>
<pre><code class="language-java">//查询当前sku所属spu的其他sku集合的hash表
Map&lt;String,String&gt; skuSaleAttrHash=new HashMap&lt;&gt;();
List&lt;PmsSkuInfo&gt; pmsSkuInfos=skuService.getSkuSaleAttrValueListBySpu(skuInfo.getProductId());

for (PmsSkuInfo pmsSkuInfo : pmsSkuInfos) {
    String k=&quot;&quot;;
    String v=pmsSkuInfo.getId();
    List&lt;PmsSkuSaleAttrValue&gt; skuSaleAttrValueList = pmsSkuInfo.getSkuSaleAttrValueList();
    for (PmsSkuSaleAttrValue pmsSkuSaleAttrValue : skuSaleAttrValueList) {
        k+=pmsSkuSaleAttrValue.getSaleAttrValueId()+&quot;|&quot;;
    }
    skuSaleAttrHash.put(k,v);
}
//将sku销售属性hash放到页面
String skuSaleAttrHashJsonStr = JSON.toJSONString(skuSaleAttrHash);
map.put(&quot;skuSaleAttrHashJsonStr&quot;,skuSaleAttrHashJsonStr);
</code></pre>
<p>SkuServiceImpl:</p>
<pre><code class="language-java">@Override
public List&lt;PmsSkuInfo&gt; getSkuSaleAttrValueListBySpu(String productId) {
    List&lt;PmsSkuInfo&gt; skuInfos = pmsSkuInfoMapper.selectSkuSaleAttrValueListBySpu(productId);
    return skuInfos;
}
</code></pre>
<p>PmsSkuInfoMapper.xml:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.atguigu.gmall.manage.mapper.PmsSkuInfoMapper&quot;&gt;
    &lt;select id=&quot;selectSkuSaleAttrValueListBySpu&quot; resultMap=&quot;selectSkuSaleAttrValueListBySpuMap&quot;&gt;
        SELECT
            si.*,ssav.*,
            si.id as si_id,
            ssav.id as ssav_id
        FROM
            pms_sku_info si,
            pms_sku_sale_attr_value ssav
        WHERE
            si.product_id = #{productId}
            AND si.id = ssav.sku_id;
    &lt;/select&gt;
    
    &lt;resultMap id=&quot;selectSkuSaleAttrValueListBySpuMap&quot; type=&quot;com.atguigu.gmall.bean.PmsSkuInfo&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;si_id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;skuSaleAttrValueList&quot; ofType=&quot;com.atguigu.gmall.bean.PmsSkuSaleAttrValue&quot; autoMapping=&quot;true&quot;&gt;
            &lt;result column=&quot;ssav_id&quot; property=&quot;id&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ol>
<h5 id="6-使用缓存redis解决页面并发问题"><a class="header-anchor" href="#6-使用缓存redis解决页面并发问题">¶</a>6.使用缓存redis解决页面并发问题</h5>
<ol>
<li>
<p>缓存使用的简单方式</p>
<p>连接缓存、查询缓存、如果缓存中没有则查询mysql、mysql查询结果存入redis</p>
</li>
<li>
<p>redis的整合步骤</p>
<p>A）将redis整合到项目中（redis+spring）</p>
<p>B）设计数据存储策略（核心就是如何设计key）</p>
<p>​	企业中的存储策略：<br>
​	数据对象名：数据对象id：对象属性<br>
​	eg：User:123:password，User:123:username，sku:108:info</p>
<p>C</p>
</li>
</ol>
<h5 id="7-redis的整合过程"><a class="header-anchor" href="#7-redis的整合过程">¶</a>7.redis的整合过程</h5>
<ol>
<li>
<p>引入pom依赖（本工程所有redis统一放入service-util中）</p>
<pre><code class="language-xml">&lt;!--redis--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>写一个redis的工具类（将redis池初始化到spring容器中）</p>
<pre><code class="language-java">public class RedisUtil {
    private  JedisPool jedisPool;
    public void initPool(String host,int port ,int database){
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(200);				//最大连接数200
        poolConfig.setMaxIdle(30);		
        poolConfig.setBlockWhenExhausted(true);
        poolConfig.setMaxWaitMillis(10*1000);		//延迟时间10s
        poolConfig.setTestOnBorrow(true);
        jedisPool=new JedisPool(poolConfig,host,port,20*1000);
    }
    public Jedis getJedis(){
        Jedis jedis = jedisPool.getResource();
        return jedis;
    }
}
</code></pre>
</li>
<li>
<p>写一个Spring整合redis的配置类</p>
<p>将redis的连接池创建到spring容器中</p>
<pre><code class="language-java">@Configuration
public class RedisConfig {
    //读取配置文件中的redis的ip地址
    @Value(&quot;${spring.redis.host:disabled}&quot;)
    private String host;

    @Value(&quot;${spring.redis.port:0}&quot;)
    private int port;

    @Value(&quot;${spring.redis.database:0}&quot;)
    private int database;
    
    @Bean
    public RedisUtil getRedisUtil(){
        if(host.equals(&quot;disabled&quot;)){
            return null;
        }
        RedisUtil redisUtil=new RedisUtil();
        redisUtil.initPool(host,port,database);
        return redisUtil;
    }
}
</code></pre>
</li>
<li>
<p>注意：每个应用工程引入service-util后，单独配置自己的redis文件，service-util模块中的配置文件没有作用</p>
</li>
<li>
<p>注意：主应用要放在项目结构最外面（至少跟config和util平级）才能访问到config和util中的内容：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200211104743527.png" alt="image-20200211104743527"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200211104829919.png" alt="image-20200211104829919"></p>
</li>
</ol>
<h5 id="8-redis常见问题-注意事项"><a class="header-anchor" href="#8-redis常见问题-注意事项">¶</a>8.redis常见问题&amp;注意事项</h5>
<ol>
<li>
<p>报错：cont get a connection from the pool</p>
</li>
<li>
<p>命令：</p>
<p>启动redis：</p>
<pre><code class="language-sh">redis-server
</code></pre>
<p>查看redis是否启动</p>
<pre><code class="language-sh">redis-cli （或：redis-cli -h 本机IP -p 6379）
</code></pre>
</li>
<li>
<p><strong>缓存在高并发和安全压力下的一些问题：</strong></p>
<p><strong>缓存击穿：</strong></p>
<p>​	对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发访问，则称他们为一些非常”热点“的数据。需考虑到：如果这个key在大量请求同时进来之前正好失效，那么所有对这个key的查询都落在db上，这种现象称之为缓存击穿。</p>
<p><strong>缓存穿透</strong>：</p>
<p>​	指 <strong>利用redis和mysql的机制（redis缓存一旦不存在就访问mysql）去查询一个不存在的数据</strong>，直接绕过缓存访问mysql制造db请求压力，由于缓存不命中，将去查询数据库，但是数据库中也无此记录，并且处于容错考虑，我们没有将这次查询的null写入缓存，这将导致这个不存在的数据每次请求都要到存储层查询，失去了缓存的意义。<strong>流量大时，可能DB就挂掉了</strong>。漏洞所在：有人利用不存在的key频繁地攻击我们的应用。</p>
<p>​	解决：一般在代码中防止该现象——空结果进行缓存，但它的过期时间很短，最长不超5min</p>
<p><strong>缓存雪崩：</strong></p>
<p>​	指 在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB上，DB瞬时压力过重。（多个热点key同时失效）</p>
<p>​	解决：原有的失效时间基础之上增加一个随机值，比如1-5min随机，这样每一个缓存的过期时间的重复率会降低，很难遇到集体失效的情况</p>
</li>
</ol>
<h5 id="9-如何解决缓存击穿问题"><a class="header-anchor" href="#9-如何解决缓存击穿问题">¶</a>9. 如何解决缓存击穿问题</h5>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200212012428994.png" alt="image-20200212012428994"></p>
<p>使用redis数据库的分布式锁，解决mysql的访问压力问题</p>
<p>两种分布式锁：</p>
<p>​	<img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200212105008218.png" alt="image-20200212105008218"></p>
<ol>
<li>
<p><strong>redis自带分布式锁</strong>：set px nx</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200212105924576.png" alt="image-20200212105924576"></p>
<p><strong>两种意外情况：</strong></p>
<p>问题1：如果在redis中的锁已经过期，然后锁过期的那个请求又执行完毕，回来删锁，删除了其他线程的锁，怎么解决？<br>
解决方案：生成UUID字符串 token ，将自己锁的value值设置为token，回来删锁时先确保value值为token再删除</p>
<p>问题2：如果碰巧在查询redis锁还没删除的时候，正在网络传输，锁过期了，怎么办？</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200213004042057.png" alt="image-20200213004042057"></p>
<p>解决方案：执行lua脚本来删除锁，能够将获得token值与判断删除合并为一个原子性操作</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200213004646769.png" alt="image-20200213004646769"></p>
<p>整合redis到本项目中：</p>
<pre><code class="language-java">@Override
public PmsSkuInfo getSkuById(String skuId) {
    PmsSkuInfo skuInfo=null;
    //连接缓存
    Jedis jedis=redisUtil.getJedis();

    //查询缓存
    String skuKey=&quot;sku:&quot;+skuId+&quot;:info&quot;;
    String skuJson=jedis.get(skuKey);

    if (StringUtils.isNotBlank(skuJson)){
        skuInfo= JSON.parseObject(skuJson,PmsSkuInfo.class);
    }else {
        //如果缓存中没有，查询Mysql
        //设置分布式锁
        String token= UUID.randomUUID().toString();
        String OK = jedis.set(&quot;sku:&quot;+skuId+&quot;:lock&quot;, token, &quot;nx&quot;, &quot;px&quot;, 10);//拿到锁的线程有10s的过期时间
        if (StringUtils.isNotBlank(OK)&amp;&amp;OK.equals(&quot;OK&quot;)){
            //设置成功，有权在10s的过期时间内访问数据库
            skuInfo=getSkuByIdFromDb(skuId);
            //                try {
            //                    Thread.sleep(5000);
            //                } catch (InterruptedException e) {
            //                    e.printStackTrace();
            //                }
            //将mysql查询结果存入redis
            if (skuInfo!=null){
                jedis.set(skuKey,JSON.toJSONString(skuInfo));
            }else{
                //数据库中不存在该sku
                //为了防止缓存穿透，null或空字符串值设置给redis
                jedis.setex(skuKey,60*3,JSON.toJSONString(&quot;&quot;));
            }
            //在访问mysql后，将分布式锁释放
            String lockToken = jedis.get(&quot;sku:&quot; + skuId + &quot;:lock&quot;);
            if (StringUtils.isNotBlank(lockToken)&amp;&amp;lockToken.equals(token)){
                jedis.del(&quot;sku:&quot;+skuId+&quot;:lock&quot;);    //用token字段确认删除的是自己sku的锁
            }
        }else {
            //设置失败，自旋（该线程睡眠几秒后重新尝试访问）
            getSkuById(skuId);
        }
    }

    jedis.close();
    return skuInfo;
}
</code></pre>
</li>
<li>
<p><strong>redisson框架</strong>：一个redis的 juc (java.util.concurrent) 的lock功能的客户端的实现（既有jedis功能，又有juc功能）</p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p><strong>引入Maven依赖：</strong>(service-util pom)</p>
<pre><code class="language-java">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.redisson&lt;/groupId&gt;
    &lt;artifactId&gt;redisson&lt;/artifactId&gt;
    &lt;version&gt;3.10.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>配置</p>
<pre><code class="language-properties">spring.redis.host=192.168.159.130
spring.redis.port=6379
</code></pre>
<p>配置类：</p>
<pre><code class="language-java">@Configuration
public class GmallRedissonConfig {

    @Value(&quot;${spring.redis.host}&quot;)
    private String host;

    @Value(&quot;${spring.redis.port}&quot;)
    private String port;

    @Bean
    public RedissonClient redissonClient(){
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://&quot;+host+&quot;:&quot;+port);
        RedissonClient redisson = Redisson.create(config);
        return redisson;
    }
}
</code></pre>
<p>Redisson实现了JUC的lock锁，并且可以在分布式redis环境下使用</p>
<p><strong>压力测试：</strong></p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200213190221163.png" alt="image-20200213190221163"></p>
<p>我们创建一个测试项目：gmall-redisson-test，为其 添加Controller：</p>
<pre><code class="language-java">@Controller
public class RedissonController {
    @Autowired
    RedisUtil redisUtil;

    @Autowired
    RedissonClient redissonClient;

    @RequestMapping(&quot;testRedisson&quot;)
    @ResponseBody
    public String testRedisson(){
        Jedis jedis=redisUtil.getJedis();
//        RLock lock=redissonClient.getLock(&quot;lock&quot;);
        String v=jedis.get(&quot;k&quot;);
        if (StringUtils.isBlank(v)){
            v=&quot;1&quot;;
        }
        System.out.println(v);
        jedis.set(&quot;k&quot;,Integer.parseInt(v)+1+&quot;&quot;);
        jedis.close();
        return &quot;success&quot;;
    }
}
</code></pre>
<p><strong>redisson-nginx负载均衡配置</strong></p>
<blockquote>
<p>Nginx-windows安装：<a href="https://www.cnblogs.com/jiangwangxiang/p/8481661.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangwangxiang/p/8481661.html</a></p>
</blockquote>
<p>nginx.conf:</p>
<pre><code class="language-sh">upstream redisTest{
    server	127.0.0.1:8080 weight=3;
    server	127.0.0.1:8081 weight=3;
    server	127.0.0.1:8082 weight=3;
}
    
server {
    listen       80;
    location / {
    #root   html;
    proxy_pass http://redisTest;
    index  index.html index.htm;
}
</code></pre>
<p>在nginx目录下开启cmd窗口，启动Nginx：</p>
<pre><code class="language-sh">start nginx
</code></pre>
<p>Nginx关闭命令：</p>
<pre><code class="language-sh">nginx -s stop 或 nginx -s quit
</code></pre>
<p>访问localhost/testRedisson即可</p>
<p><strong>下载Apache测试工具</strong></p>
<blockquote>
<p>windows下载链接：<a href="https://www.apachehaus.com/cgi-bin/download.plx" target="_blank" rel="noopener">https://www.apachehaus.com/cgi-bin/download.plx</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214032954828.png" alt="image-20200214032954828"></p>
<p>解压后，找到安装目录下的httpd.conf，修改为自己的安装目录</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214035343079.png" alt="image-20200214035343079"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214043122367.png" alt="image-20200214043122367"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214043625639.png" alt="image-20200214043625639"></p>
<p><strong>启动Apache服务：</strong></p>
<p>查看被占用的端口：</p>
<pre><code class="language-sh">netstat -ano | findstr &quot;443&quot;(端口号)
</code></pre>
<p>Apache启动时443端口经常被占用，我们把它改成442</p>
<blockquote>
<p>启动Apache会占用443端口，而443被其他程序占用了。我们只需将Apache默认端口443改掉就行。网上搜了一下，说是更改Apache24\conf\extra\httpd-ssl.conf 文件中的443端口，我试了下，并没有什么用。</p>
<p>经过一番研究，在httpd.conf看到ssl_module引用的是httpd-ahssl.conf。然后找到httpd-ahssl.conf，修改文件里的443为442即可。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214052537154.png" alt="image-20200214052537154"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214052727160.png" alt="image-20200214052727160"></p>
<p><strong>压力测试：</strong></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214052916070.png" alt="image-20200214052916070"></p>
<p>先清除redis中已有的kv缓存：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214053251755.png" alt="image-20200214053251755"></p>
<p>开始测试（不加锁）：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214054033272.png" alt="image-20200214054033272"></p>
<p>加锁：</p>
<pre><code class="language-java">@RequestMapping(&quot;lockTest&quot;)
@ResponseBody
public String lockTest(){
    Jedis jedis = redisUtil.getJedis();// redis链接
    RLock lock = redissonClient.getLock(&quot;redis-lock&quot;);//分布锁
    //加锁
    lock.lock();
    try {
        String v = jedis.get(&quot;k&quot;);//获取value
        System.err.print(&quot;==&gt;&quot;+v);//打印value
        if(StringUtil.isBlank(v)){
            v = &quot;1&quot;;
        }
        int inum = Integer.parseInt(v);//获得value的值
        jedis.set(&quot;k&quot;, inum+1+&quot;&quot;);//value增加1
        jedis.close();
    } finally {
        lock.unlock();
    }
    return &quot;success&quot;;
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200214060626176.png" alt="image-20200214060626176"></p>
<p>补充：<strong>AB命令参数：</strong></p>
<blockquote>
<p>-n 即requests，用于指定压力测试总共的执行次数</p>
<p>-c 即concurrency，用于指定压力测试的并发数。</p>
<p>-t即timelimit，等待响应的最大时间(单位：秒)。</p>
<p>-b即windowsize，TCP发送/接收的缓冲大小(单位：字节)。</p>
<p>-p即postfile，发送POST请求时需要上传的文件，此外还必须设置-T参数。</p>
<p>-u即putfile，发送PUT请求时需要上传的文件，此外还必须设置-T参数。</p>
<p>-T即content-type，用于设置Content-Type请求头信息，例如：application/x-www-form-urlencoded，默认值为text/plain。</p>
<p>-v即verbosity，指定打印帮助信息的冗余级别。</p>
<p>-w以HTML表格形式打印结果。</p>
<p>-i使用HEAD请求代替GET请求。</p>
<p>-x插入字符串作为table标签的属性。</p>
<p>-y插入字符串作为tr标签的属性。</p>
<p>-z插入字符串作为td标签的属性。</p>
<p>-C添加cookie信息，例如：“Apache=1234”(可以重复该参数选项以添加多个)。</p>
<p>-H添加任意的请求头，例如：“Accept-Encoding: gzip”，请求头将会添加在现有的多个请求头之后(可以重复该参数选项以添加多个)。</p>
<p>-A添加一个基本的网络认证信息，用户名和密码之间用英文冒号隔开。</p>
<p>-P添加一个基本的代理认证信息，用户名和密码之间用英文冒号隔开。</p>
<p>-X指定使用的代理服务器和端口号，例如:“126.10.10.3:88”。</p>
<p>-V打印版本号并退出。</p>
<p>-k使用HTTP的KeepAlive特性。</p>
<p>-d不显示百分比。</p>
<p>-S不显示预估和警告信息。</p>
<p>-g输出结果信息到gnuplot格式的文件中。</p>
<p>-e输出结果信息到CSV格式的文件中。</p>
<p>-r指定接收到错误信息时不退出程序。</p>
<p>-h显示用法信息，其实就是ab -help。</p>
</blockquote>
<h3 id="P109-商城搜索：ElasticSearch"><a class="header-anchor" href="#P109-商城搜索：ElasticSearch">¶</a>P109 商城搜索：ElasticSearch</h3>
<h4 id="介绍："><a class="header-anchor" href="#介绍：">¶</a>介绍：</h4>
<h5 id="1-搜索引擎"><a class="header-anchor" href="#1-搜索引擎">¶</a>1. 搜索引擎</h5>
<p>elasticSearch6（和elasticSearch5的区别在于，root用户权限、一个库是否能建立多个表）</p>
<p>文本搜索（以空间换时间的算法）</p>
<p>与同类产品（solr、Hermes）相比，elasticSearch和solr都是基于Lucene（Apache），默认以集群方式工作</p>
<p>搜索引擎 的工作原理是什么？（以百度和google为例）</p>
<pre><code>1. 爬取
2. 分析
3. 查询
</code></pre>
<p>ElasticSearch（搜索引擎）的算法</p>
<p>​	倒排索引：在内容上建立索引，用内容去匹配索引<br>
​	B-Tree、B+ Tree</p>
<p><strong>2.安装</strong></p>
<p>​	安装环境：CentOS7+jdk8<br>
​	配置文件：elasticSearch.yml、jvmOptions.yml</p>
<p>创建目录、上传、解压：</p>
<pre><code class="language-sh">mkdir -p /opt/es
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200215074729424.png" alt="image-20200215074729424"></p>
<pre><code class="language-sh">cd es
chmod 777 *
</code></pre>
<pre><code class="language-sh">tar -zxvf elasticsearch-6.3.1.tar.gz
</code></pre>
<p>配置：</p>
<p>​	启动：切换到elasticsearch-6.3.1的bin目录下，输入./elasticsearch</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200215080730786.png" alt="image-20200215080730786"></p>
<p>​	可见：需要非root用户才能启动，我们为es创建一个用户：</p>
<pre><code class="language-sh">adduser es
su es
</code></pre>
<p>​	切换用户后启动也会报错：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200215081254330.png" alt="image-20200215081254330"></p>
<p>​	我们需要配置如下两个文件（配置时需要切换回root）：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200215081456409.png" alt="image-20200215081456409"></p>
<p>​	<strong>jvm.options</strong>（jvm配置文件）:</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200215081754910.png" alt="image-20200215081754910"></p>
<p>​	<strong>elasticsearch.yml</strong>（集群配置文件）（elasticsearch无法访问data目录：es的软件和日志数据目录）（如果不用root用户解压，可直接用es用户解压，解压后可避免配置权限）:</p>
<ol>
<li>给用户授权：chown -R es:es /opt/es/elasticserch-6.3.1/</li>
<li>切换用户：su es</li>
<li>通过命令重写启动服务：sh /opt/mysoft/elasticsearch/bin/elasticsearch -d</li>
<li>输入：curl <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a> 测试能够正常访问</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200215122349067.png" alt="image-20200215122349067"></p>
<ol start="5">
<li>修改conf/elasticsearch.yml ，配置host地址（配置成本机地址，允许访问）：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200215115116549.png" alt="image-20200215115116549"></p>
<ol start="6">
<li>
<p>重启elasticsearch：</p>
<p>ps -ef | grep elastic 查找并杀死进程</p>
<p>切换到bin目录启动：./elasticsearch</p>
</li>
<li>
<p>启动后将会报错，因为es使用的最大线程数、最大内存数、访问的最大文件数皆不足</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200215121818138.png" alt="image-20200215121818138"></p>
<ol start="8">
<li>
<p>修改linux的配置（配合es的启动需求）：</p>
<p>A）修改linux的limits配置文件，设置内存、线程和文件</p>
<p>nofile - 打开文件的最大数目<br>
noproc - 进程的最大数目<br>
soft - 指当前系统生效的设置值<br>
hard - 表明系统中所能设定的最大值</p>
<p>当设置为：</p>
<pre><code class="language-sh">* hard nofile 655360
* soft nofile 131072
* hard nproc 4096
* soft nproc 2048
</code></pre>
<pre><code class="language-sh">vim /etc/security/limits.conf 
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200216040504009.png" alt="image-20200216040504009"></p>
<p>设置完后，保存并退出，然后输入：</p>
<pre><code class="language-sh">source  /etc/security/limits.conf 
</code></pre>
<p>然后修改最大内存：</p>
<pre><code class="language-sh">vim /etc/sysctl.conf
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200216040932930.png" alt="image-20200216040932930"></p>
<p>设置完成后，保存退出，然后输入如下命令使之生效：</p>
<pre><code class="language-sh">sysctl -p
</code></pre>
<p>然后切换回es用户，就可正常启动elasticsearch了我们，我们希望日志信息不输出在命令行（后台启动）：</p>
<pre><code class="language-sh"></code></pre>
</li>
</ol>
<p>nohup ./elasticsearch &amp;</p>
<pre><code>
![image-20200216042018592](https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_谷粒商城/image-20200216042018592.png)

**总结：**

整个es的配置有四处文件需要修改：    
elasticsearch.yml		es启动的host地址    
jvm.options				  配置es的虚拟机内存   
limits.conf					 配置linux的线程内存和文件   
sysctl.conf					 配置系统允许的软件运行内存

##### 2.Search API

1. elasticsearch通过（9200端口）http协议进行交互

2. 基本概念

**全文搜索：**

全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。

**倒排索引（Inverted Index）：**

该索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。Elasticsearch能够实现快速、高效的搜索功能，正是基于倒排索引原理。

**节点&amp;集群（Node &amp; Cluster）：**

Elasticsearch 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个Elasticsearch实例。单个Elasticsearch实例称为一个节点（Node），一组节点构成一个集群（Cluster）。

**索引（Index）：**

Elasticsearch 数据管理的顶层单位就叫做 Index（索引），相当于关系型数据库里的数据库的概念。另外，每个Index的名字必须是小写。

**文档（Document）：**

  Index里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。

**类型（Type）：**

  Document 可以分组，比如employee这个 Index 里面，可以按部门分组，也可以按职级分组。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document，类似关系型数据库中的数据表。
  不同的 Type 应该有相似的结构（Schema），性质完全不同的数据（比如 products 和 logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。

**文档元数据（Document metadata）：**

  文档元数据为_index, _type, _id, 这三者可以唯一表示一个文档，_index表示文档在哪存放，_type表示文档的对象类别，_id为文档的唯一标识。

**字段（Fields）：**

  每个Document都类似一个JSON结构，它包含了许多字段，每个字段都有其对应的值，多个字段组成了一个 Document，可以类比关系型数据库数据表中的字段。
  在 Elasticsearch 中，文档（Document）归属于一种类型（Type），而这些类型存在于索引（Index）中，下图展示了Elasticsearch与传统关系型数据库的类比：

![img](https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_谷粒商城/webp)

| Index    | 库             |
| -------- | -------------- |
| Type     | 表             |
| Document | 行（一条数据） |
| Field    | 字段           |

3. 开发工具Kibana

Kibana 是为 Elasticsearch设计的开源分析和可视化平台。你可以使用 Kibana 来搜索，查看存储在 Elasticsearch 索引中的数据并与之交互。你可以很容易实现高级的数据分析和可视化，以图标的形式展现出来。

安装：首先解压压缩包

![image-20200217031144801](https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_谷粒商城/image-20200217031144801.png)

然后进入kibana.yml配置kibana的es信息：

![image-20200217031527191](https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_谷粒商城/image-20200217031527191.png)

 启动kibana：

![image-20200217031657677](https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_谷粒商城/image-20200217031657677.png)

（停止kibana）：

![image-20200217032301229](https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_谷粒商城/image-20200217032301229.png)

kibana端口号为5601：

![image-20200217032453019](https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_谷粒商城/image-20200217032453019.png)

##### 3.ES简单的增删改查

ES采用RestfulAPI进行增删改查

在

**新增PUT**：

PUT /（index，索引，库）/（type，表）/id

```html
PUT /movie_index/movie/1
{ &quot;id&quot;:1,
&quot;name&quot;:&quot;operation red sea&quot;,
&quot;doubanScore&quot;:8.5,
&quot;actorList&quot;:[  
{&quot;id&quot;:1,&quot;name&quot;:&quot;zhang yi&quot;},
{&quot;id&quot;:2,&quot;name&quot;:&quot;hai qing&quot;},
{&quot;id&quot;:3,&quot;name&quot;:&quot;zhang han yu&quot;}
]
}

PUT /movie_index/movie/2
{
&quot;id&quot;:2,
&quot;name&quot;:&quot;operation meigong river&quot;,
&quot;doubanScore&quot;:8.0,
&quot;actorList&quot;:[  
{&quot;id&quot;:3,&quot;name&quot;:&quot;zhang han yu&quot;}
]
}

PUT /movie_index/movie/3
{
&quot;id&quot;:3,
&quot;name&quot;:&quot;incident red sea&quot;,
&quot;doubanScore&quot;:5.0,
&quot;actorList&quot;:[  
{&quot;id&quot;:4,&quot;name&quot;:&quot;zhang chen&quot;}
]
}
</code></pre>
<p><strong>注意</strong>：在elasticsearch6中，一个index下只能由一个type，本例中 movie_index 下已有 movie ，故当再往其中新增 movie_chn 时将报错。elasticsearch5中没有这个规定。</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200218053916092.png" alt="image-20200218053916092"></p>
<p><strong>更新PUT:</strong></p>
<p>将原有记录覆盖</p>
<p><strong>查找GET</strong>：</p>
<pre><code class="language-html">GET movie_index/_search
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200218050559352.png" alt="image-20200218050559352"></p>
<p>查找所有字段name中包含“red”的记录：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200218051221348.png" alt="image-20200218051221348"></p>
<h5 id="4-ES对中文的处理与解析："><a class="header-anchor" href="#4-ES对中文的处理与解析：">¶</a>4.ES对中文的处理与解析：</h5>
<p>我们先新增中文document：</p>
<pre><code class="language-html">PUT /movie_chn/movie/1
{ &quot;id&quot;:1,
  &quot;name&quot;:&quot;红海行动&quot;,
  &quot;doubanScore&quot;:8.5,
  &quot;actorList&quot;:[  
  {&quot;id&quot;:1,&quot;name&quot;:&quot;张译&quot;},
  {&quot;id&quot;:2,&quot;name&quot;:&quot;海清&quot;},
  {&quot;id&quot;:3,&quot;name&quot;:&quot;张涵予&quot;}
 ]
}
PUT /movie_chn/movie/2
{
  &quot;id&quot;:2,
  &quot;name&quot;:&quot;湄公河行动&quot;,
  &quot;doubanScore&quot;:8.0,
  &quot;actorList&quot;:[  
{&quot;id&quot;:3,&quot;name&quot;:&quot;张涵予&quot;}
]
}
PUT /movie_chn/movie/3
{
  &quot;id&quot;:3,
  &quot;name&quot;:&quot;红海事件&quot;,
  &quot;doubanScore&quot;:5.0,
  &quot;actorList&quot;:[  
{&quot;id&quot;:4,&quot;name&quot;:&quot;张晨&quot;}
]
}

PUT /movie_index/movie/4
{ &quot;id&quot;:4,
  &quot;name&quot;:&quot;红海行动&quot;,
  &quot;doubanScore&quot;:8.5,
  &quot;actorList&quot;:[  
  {&quot;id&quot;:1,&quot;name&quot;:&quot;张译&quot;},
  {&quot;id&quot;:2,&quot;name&quot;:&quot;海清&quot;},
  {&quot;id&quot;:3,&quot;name&quot;:&quot;张涵予&quot;}
 ]
}
PUT /movie_index/movie/5
{
  &quot;id&quot;:5,
  &quot;name&quot;:&quot;湄公河行动&quot;,
  &quot;doubanScore&quot;:8.0,
  &quot;actorList&quot;:[  
{&quot;id&quot;:3,&quot;name&quot;:&quot;张涵予&quot;}
]
}

PUT /movie_index/movie/6
{
  &quot;id&quot;:6,
  &quot;name&quot;:&quot;红海事件&quot;,
  &quot;doubanScore&quot;:5.0,
  &quot;actorList&quot;:[  
{&quot;id&quot;:4,&quot;name&quot;:&quot;张晨&quot;}
]
}
</code></pre>
<p><strong>对于中文的分词：</strong></p>
<p>若不做任何处理，所有中文将逐字拆分，我们要加入中文分词器（本项目采用IK分词器）</p>
<p>我们先进入插件目录：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200218105832822.png" alt="image-20200218105832822"></p>
<p>在plugins目录下解压一层目录就可以</p>
<p>加入分词器后，就能进行中文搜索了：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200218114554353.png" alt="image-20200218114554353"></p>
<p>IK（中英文分词器）有两个模式：</p>
<ol>
<li>ik_smart（简易分词）</li>
<li>ik_max_word（尽最大可能分词）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200218113732021.png" alt="image-20200218113732021"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200218113809918.png" alt="image-20200218113809918"></p>
<p>商品标题：应当用最大可能分词（标题本身不长）<br>
商品描述：应当用简易分词</p>
<h5 id="5-ES的集群"><a class="header-anchor" href="#5-ES的集群">¶</a>5.ES的集群</h5>
<p>首先用VMWare克隆一台虚拟机与原有虚拟机构成集群</p>
<p>然后修改被克隆虚拟机IP：</p>
<ol>
<li>
<p>进入IP配置文件目录，修改配置文件</p>
<pre><code class="language-sh">cd /etc/sysconfig/network-scripts/
</code></pre>
<pre><code class="language-sh">vim ifcfg-ens33
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200219093645230.png" alt="image-20200219093645230"></p>
</li>
<li>
<p>重启网络</p>
<pre><code class="language-sh">service network restart
</code></pre>
</li>
</ol>
<p>然后切换到elasticsearch/config/目录下，配置elasticsearch.yml，启动集群:</p>
<p>对于集群中的每一台设备，按如下格式修改elasticsearch.yml:</p>
<pre><code class="language-yml">cluster.name: aubin-cluster     #必须相同 
# 集群名称（不能重复）
node.name: els1 #（必须不同）
# 节点名称，仅仅是描述名称，用于在日志中区分（自定义）
#指定了该节点可能成为 master 节点，还可以是数据节点
node.master: true
node.data: true
path.data: /opt/data
# 数据的默认存放路径（自定义）
path.logs: /opt/logs 
# 日志的默认存放路径 
network.host: 192.168.0.1 
# 当前节点的IP地址 
http.port: 9200 
# 对外提供服务的端口
transport.tcp.port: 9300
#9300为集群服务的端口 
discovery.zen.ping.unicast.hosts: [&quot;172.18.68.11&quot;, &quot;172.18.68.12&quot;,&quot;172.18.68.13&quot;] 
# 集群个节点IP地址，也可以使用域名，需要各节点能够解析 (除本机外的其他节点)
discovery.zen.minimum_master_nodes: 2 
# 为了避免脑裂，集群节点数最少为 半数+1
</code></pre>
<p>以root身份在/opt目录下创建data、logs两个目录，然后让其他用户有权访问：chmod 777 data/logs</p>
<p>各个节点切换到es用户，后台启动elasticsearch</p>
<h5 id="6-集群的工作原理"><a class="header-anchor" href="#6-集群的工作原理">¶</a>6.集群的工作原理</h5>
<p>我们可以用cerebro管理集群。</p>
<p>解压cerebro压缩包，进入bin目录下，然后以管理员身份运行cerebro.bat文件</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200220051619155.png" alt="image-20200220051619155"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200220051815506.png" alt="image-20200220051815506"></p>
<p>然后打开localhost:9000</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200220053332733.png" alt="image-20200220053332733"></p>
<table>
<thead>
<tr>
<th></th>
<th>概念、定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>节点</td>
<td>一个节点就是一个es服务器，es集群中，主节点负责集群的管理和任务的分发，一般不负责文档的增删改查</td>
</tr>
<tr>
<td>片</td>
<td>分片是实际的物理存储单元（一个Lucene实例）</td>
</tr>
<tr>
<td>索引</td>
<td>是es的逻辑单元（相当于数据库中的库），一个索引一般建立在不同机器的多个分片上</td>
</tr>
<tr>
<td>复制片</td>
<td>每个机器的分片一般在其他机器上都会有2-3个复制片（目的是提高数据的容错率）</td>
</tr>
<tr>
<td>容错</td>
<td>一旦集群中的某些机器发生故障，剩余机器会在主节点的管理下，重新分配资源（分片）</td>
</tr>
<tr>
<td>分片的路由</td>
<td>写操作（新建、删除）只在主分片上进行，然后将结果同步给复制分片<br />Sycn：主分片同步复制成功后，才返回结果给客户端 <br />Async：主分片操作成功后，在同步复制分片的同时将成功结果返回给客户端<br />读操作（查询）可在主分片或复制分片上进行</td>
</tr>
</tbody>
</table>
<h4 id="实现："><a class="header-anchor" href="#实现：">¶</a>实现：</h4>
<h5 id="7-谷粒搜索模块"><a class="header-anchor" href="#7-谷粒搜索模块">¶</a>7.谷粒搜索模块</h5>
<p>步骤：</p>
<ol>
<li>
<p>数据结构的准备</p>
<p>商城中商品的数据结构：商品名称（展示/查询）、商品价格（展示/查询）、商品图片（展示）、平台属性和属性值列表（查询）、商品描述（展示/查询）、热度值（查询）、三级分类id（查询）、商品id、主键</p>
<p>可用于查询的部分（参数结构）：（商品名称、商品价格、商品描述）（关键字）、平台属性和属性值列表、三级分类id</p>
</li>
<li>
<p>项目的初始化</p>
</li>
<li>
<p>ES客户端的整合</p>
</li>
<li>
<p>谷粒搜索代码的开发</p>
<p>搜索功能</p>
<p>面包屑功能</p>
</li>
</ol>
<h5 id="8-通过ES的mapping定义商品的数据结构"><a class="header-anchor" href="#8-通过ES的mapping定义商品的数据结构">¶</a>8. 通过ES的mapping定义商品的数据结构</h5>
<p>ElasticSearch的mapping定义是基于整个库的<br>
Mysql的数据结构字段定义是基于整个表的</p>
<p>ES的数据类型：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200220151420106.png" alt="image-20200220151420106"></p>
<p>商品数据结构：商品名称（展示/查询）、商品价格（展示/查询）、商品图片（展示）、平台属性和属性值列表（查询）、商品描述（展示/查询）、热度值（查询）、三级分类id（查询）、商品id、主键</p>
<pre><code class="language-json">PUT gmall
{
  &quot;mappings&quot;: {
    &quot;PmsSkuInfo&quot;:{
      &quot;properties&quot;: {
        &quot;id&quot;:{
          &quot;type&quot;: &quot;keyword&quot;,
          &quot;index&quot;: true
        },
        &quot;skuName&quot;: {
          &quot;type&quot;: &quot;text&quot;,
          &quot;analyzer&quot;:&quot;ik_max_word&quot;
        },
        &quot;skuDesc&quot;: {
          &quot;type&quot;: &quot;text&quot;,
          &quot;analyzer&quot;: &quot;ik_smart&quot;
        },
        &quot;catalog3Id&quot;: {
          &quot;type&quot;: &quot;keyword&quot;
        },
        &quot;price&quot;: {
          &quot;type&quot;: &quot;double&quot;
        },
        &quot;skuDefaultImg&quot;: {
          &quot;type&quot;: &quot;keyword&quot;,
          &quot;index&quot;: false
        },
        &quot;hotScore&quot;:{
          &quot;type&quot;: &quot;double&quot;
        },
        &quot;productId&quot;:{
          &quot;type&quot;: &quot;keyword&quot;
        },
        &quot;skuAttrValueList&quot;:{
          &quot;properties&quot;: {
            &quot;attrId&quot;:{
              &quot;type&quot;: &quot;keyword&quot;
            },
            &quot;valueId&quot;:{
              &quot;type&quot;: &quot;keyword&quot;
            }
          }
        }
      }
    }
  }
}
</code></pre>
<p><strong>用一个Java程序将数据库中的SKU内容导入到ElasticSearch</strong></p>
<p>首先新建一个模块：gmall-search-service，除了service模块该有的依赖外，在pom中引入ES依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/io.searchbox/jest --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.searchbox&lt;/groupId&gt;
   &lt;artifactId&gt;jest&lt;/artifactId&gt;
   &lt;version&gt;5.3.3&lt;/version&gt;
&lt;/dependency&gt;


&lt;!-- https://mvnrepository.com/artifact/net.java.dev.jna/jna --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;
   &lt;artifactId&gt;jna&lt;/artifactId&gt;
   &lt;version&gt;4.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>配置文件参照gmall-manage-service的配置文件，另外加上一行elasticsearch的urls配置：</p>
<pre><code class="language-properties"># 服务端口
server.port=8074

# jdbc配置
spring.datasource.username=root
spring.datasource.password=asdasdasd
spring.datasource.url=jdbc:mysql://localhost:3306/gmall?characterEncoding=UTF-8&amp;useSSL=false

# mybatis配置
mybatis.mapper-locations=classpath:mapper/*Mapper.xml
mybatis.configuration.map-underscore-to-camel-case=true

# dubbo的配置

# dubbo中的服务名称
spring.dubbo.application=search-service
# dubbo的通讯协议的名称
spring.dubbo.protocol.name=dubbo
# zookeeper注册中心的地址
spring.dubbo.registry.address=192.168.226.129:2181
# zookeeper的通讯协议的名称
spring.dubbo.registry.protocol=zookeeper
# dubbo的服务的扫描路径
spring.dubbo.base-package=com.atguigu.gmall

# 设置超时时间(毫秒)
spring.dubbo.consumer.timeout=8000

# ES
spring.elasticsearch.jest.uris=http://192.168.226.129:9200
</code></pre>
<p>导入原理如下：Jest能将Java对象转换成DSL语句，通过elasticsearch为Java提供的API，执行这些DSL语句将数据写入elasticsearch中</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200222071128885.png" alt="image-20200222071128885"></p>
<p>我们在gmall-search-service模块中以单元测试的形式实现这个功能：</p>
<p>GmallSearchServiceApplicationTests.java:</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class GmallSearchServiceApplicationTests {
    @Reference
    SkuService skuService;      //查询mysql
    @Autowired
    JestClient jestClient;
    @Test
    public void contextLoads() throws IOException {
        //查询mysql数据
        List&lt;PmsSkuInfo&gt; pmsSkuInfoList;
        pmsSkuInfoList=skuService.getAllSku(&quot;61&quot;);//通过catalog3Id得到所有三级目录下的商品（“手机”的catalog3Id为61），细节不做赘述，自行实现
        //转化为ES数据结构
        ArrayList&lt;PmsSearchSkuInfo&gt; pmsSearchSkuInfos= new ArrayList&lt;&gt;();
        for (PmsSkuInfo pmsSkuInfo : pmsSkuInfoList) {
            PmsSearchSkuInfo pmsSearchSkuInfo = new PmsSearchSkuInfo();
            BeanUtils.copyProperties(pmsSkuInfo,pmsSearchSkuInfo);
            pmsSearchSkuInfos.add(pmsSearchSkuInfo);
        }
        //存入ES
        for (PmsSearchSkuInfo pmsSearchSkuInfo : pmsSearchSkuInfos) {
            Index build = new Index.Builder(pmsSearchSkuInfo).index(&quot;gmall&quot;).type(&quot;PmsSkuInfo&quot;).id(pmsSearchSkuInfo.getId()).build();
            jestClient.execute(build);
        }
    }
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200222094129837.png" alt="image-20200222094129837"></p>
<p>然后执行该程序，执行前记得启动gmall-manage-service服务</p>
<p>可以看到数据库中数据已成功存入elasticsearch中：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200222094316615.png" alt="image-20200222094316615"></p>
<h5 id="9-如何定义复杂查询"><a class="header-anchor" href="#9-如何定义复杂查询">¶</a>9.如何定义复杂查询</h5>
<p>查询符合以下条件的手机：名字中带小米、4寸以下、16G内存（搜索+过滤：推荐先过滤后搜索）</p>
<pre><code class="language-json">GET gmall/PmsSkuInfo/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        {
          &quot;term&quot;: {
            &quot;skuAttrValueList.valueId&quot;: &quot;39&quot;
          }
        },
        {
          &quot;term&quot;: {
            &quot;skuAttrValueList.valueId&quot;: &quot;43&quot;
          }
        }
      ],
      &quot;must&quot;: [{
          &quot;match&quot;: {
            &quot;skuName&quot;: &quot;华为&quot;
          }
      }]
    }
  }
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200222104012655.png" alt="image-20200222104012655"></p>
<p>过滤条件 term与term之间为交集，当想要让某个过滤条件能有多个候选值时（并集），可以按如下形式写：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200222105010177.png" alt="image-20200222105010177"></p>
<p>Java中的查询API：</p>
<pre><code class="language-java">Search search = new Search.Builder(&quot;DSL的Json语句&quot;).addIndex(&quot;索引名&quot;)
    						.addType(&quot;Type名&quot;).build();
SearchResult execute = jestClient.execute(search);
</code></pre>
<p>查询API中DSL语句的封装工具类：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200222130356246.png" alt="image-20200222130356246"></p>
<p>Term条件：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200222151420712.png" alt="image-20200222151420712"></p>
<h5 id="10-前端静态资源"><a class="header-anchor" href="#10-前端静态资源">¶</a>10.前端静态资源</h5>
<p>三级分类文件资源的加载路径：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200222183155152.png" alt="image-20200222183155152"></p>
<p>修改url：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200222183318447.png" alt="image-20200222183318447"></p>
<p><img src="C:%5CUsers%5CApollos%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200222183351362.png" alt="image-20200222183351362"></p>
<h5 id="11-业务实现"><a class="header-anchor" href="#11-业务实现">¶</a>11.业务实现</h5>
<ol>
<li>
<p>controller参数传递</p>
<p>增加一个PmsSearchParam参数类，包含字段：keyword、catalog3Id、skuAttrValueList</p>
<pre><code class="language-java">@Controller
public class SearchController {
    @Reference
    SearchService searchService;

    @RequestMapping(&quot;/&quot;)
    public String index(){
        return &quot;index&quot;;
    }

    @RequestMapping(&quot;list.html&quot;)
    public String list(PmsSearchParam pmsSearchParam, ModelMap modelMap){
        List&lt;PmsSearchSkuInfo&gt; pmsSearchSkuInfos = searchService.list(pmsSearchParam);
        //调用搜索服务，返回搜索结果
        modelMap.put(&quot;skuLsInfoList&quot;,pmsSearchSkuInfos);
        return &quot;list&quot;;
    }
}
</code></pre>
</li>
<li>
<p>service业务逻辑编写</p>
<p>在测试用例中已完成</p>
</li>
<li>
<p>排序和高亮</p>
<pre><code class="language-json">GET movie_index/movie/_search
{
  &quot;query&quot;:{
    &quot;match&quot;: {&quot;name&quot;:&quot;red sea&quot;}
  },
  &quot;sort&quot;: [
    {
      &quot;doubanScore&quot;: {
        &quot;order&quot;: &quot;desc&quot;
      }
    }
  ],
  &quot;highlight&quot;: {
  		&quot;fields&quot;: {&quot;name&quot;:{} }
  }
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200223120503966.png" alt="image-20200223120503966"></p>
</li>
<li>
<p>最终Service层代码：</p>
<pre><code class="language-java">@Service
@CrossOrigin
public class SearchServiceImpl implements SearchService {
    
    @Autowired
    JestClient jestClient;
    
    @Override
    public List&lt;PmsSearchSkuInfo&gt; list(PmsSearchParam pmsSearchParam) {
        List&lt;PmsSearchSkuInfo&gt; results=new ArrayList&lt;&gt;();

        String DSL=getSearchDSL(pmsSearchParam);
//        System.err.println(DSL);
        Search search = new Search.Builder(DSL).addIndex(&quot;gmall&quot;).addType(&quot;PmsSkuInfo&quot;).build();

        SearchResult execute = null;
        try {
            execute = jestClient.execute(search);
        } catch (IOException e) {
            e.printStackTrace();
        }
        List&lt;SearchResult.Hit&lt;PmsSearchSkuInfo, Void&gt;&gt; hits = execute.getHits(PmsSearchSkuInfo.class);
        for (SearchResult.Hit&lt;PmsSearchSkuInfo, Void&gt; hit : hits) {
            PmsSearchSkuInfo source = hit.source;
            //替换为搜索高亮字段
            Map&lt;String, List&lt;String&gt;&gt; highlight = hit.highlight;
            if (highlight!=null){
                String skuName=highlight.get(&quot;skuName&quot;).get(0);
                source.setSkuName(skuName);
            }
            //添加到查询结果列表
            results.add(source);
        }
        return results;
    }

    /**
     * 由传入搜索参数得到DSL
     * @param pmsSearchParam 传入搜索参数
     * @return DSL
     */
    private String getSearchDSL(PmsSearchParam pmsSearchParam){
        List&lt;PmsSkuAttrValue&gt; skuAttrValueList = pmsSearchParam.getSkuAttrValueList();
        String keyword = pmsSearchParam.getKeyword();
        String catalog3Id = pmsSearchParam.getCatalog3Id();
        //Jest的DSL工具
        SearchSourceBuilder sourceBuilder=new SearchSourceBuilder();
        //bool
        BoolQueryBuilder boolQueryBuilder=new BoolQueryBuilder();
        //filter
        if (StringUtils.isNotBlank(catalog3Id)){
            TermQueryBuilder termQueryBuilder=new TermQueryBuilder(&quot;catalog3Id&quot;,catalog3Id);
            boolQueryBuilder.filter(termQueryBuilder);
        }
        if (skuAttrValueList!=null){
            for (PmsSkuAttrValue pmsSkuAttrValue : skuAttrValueList) {
                TermQueryBuilder termQueryBuilder=new TermQueryBuilder(&quot;skuAttrValueList.valueId&quot;,pmsSkuAttrValue.getValueId());
                boolQueryBuilder.filter(termQueryBuilder);
            }
        }
        //must
        if (StringUtils.isNotBlank(keyword)){
            MatchQueryBuilder matchQueryBuilder=new MatchQueryBuilder(&quot;skuName&quot;,keyword);
            boolQueryBuilder.must(matchQueryBuilder);
        }
        //query
        sourceBuilder.query(boolQueryBuilder);
        //from
        sourceBuilder.from(0);
        //size
        sourceBuilder.size(100);
        //highlight
        HighlightBuilder highlightBuilder=new HighlightBuilder();
        highlightBuilder.preTags(&quot;&lt;span style='color:red;'&gt;&quot;);
        highlightBuilder.field(&quot;skuName&quot;);
        highlightBuilder.postTags(&quot;&lt;/span&gt;&quot;);
        sourceBuilder.highlight(highlightBuilder);
        //sort
        sourceBuilder.sort(&quot;productId&quot;, SortOrder.DESC);

        return sourceBuilder.toString();
    }
}
</code></pre>
</li>
</ol>
<h5 id="12-搜索页面品台属性列表"><a class="header-anchor" href="#12-搜索页面品台属性列表">¶</a>12.搜索页面品台属性列表</h5>
<p>平台属性列表是从搜索结果中抽取出来的，不是根据三级分类id查询的所有平台属性的集合</p>
<p>抽取方案：</p>
<ol>
<li>
<p>ES中使用aggregation聚合函数（效率低，不推荐）：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200223152309880.png" alt="image-20200223152309880"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200223152802225.png" alt="image-20200223152802225"></p>
</li>
<li>
<p>Java代码抽取平台属性：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200223153111880.png" alt="image-20200223153111880"></p>
<p>A）根据skuId从mysql中查询平台属性值的ID集合（不推荐）</p>
<pre><code class="language-mysql">select distinct value_id from pms_sku_attr_value where sku_id in (pmsSearchSkuInfos..)
</code></pre>
<p>B）直接用Java集合进行处理</p>
<p>用Set集合去重抽取属性值id</p>
<pre><code class="language-java">//抽取检索结果所包含的平台属性集合
Set&lt;String&gt; valueIdSet=new HashSet&lt;&gt;();
for (PmsSearchSkuInfo pmsSearchSkuInfo : pmsSearchSkuInfos) {
    List&lt;PmsSkuAttrValue&gt; skuAttrValueList = pmsSearchSkuInfo.getSkuAttrValueList();
    for (PmsSkuAttrValue pmsSkuAttrValue : skuAttrValueList) {
        String valueId=pmsSkuAttrValue.getValueId();
        valueIdSet.add(valueId);
    }
}
//根据valueId将属性列表查询出来
List&lt;PmsBaseAttrInfo&gt; pmsBaseAttrInfos = attrService.
    									getAttrValueListByValueId(valueIdSet);
modelMap.put(&quot;attrList&quot;,pmsBaseAttrInfos);
</code></pre>
<p>调用属性服务attrService根据属性值id将平台属性的集合列表查询出来：</p>
<pre><code class="language-sql">select * from
pms_base_attr_info ba , pms_base_attr_value bv
where ba.id=bv.attr_id and bv.id in (valueIdSet..)
</code></pre>
<p>AttrServiceImpl:</p>
<pre><code class="language-java">public List&lt;PmsBaseAttrInfo&gt; getAttrValueListByValueId(Set&lt;String&gt; valueIdSet) {
    String valueIdStr=StringUtils.join(valueIdSet,&quot;,&quot;);     //eg: &quot;41,45,46&quot;
    List&lt;PmsBaseAttrInfo&gt; pmsBaseAttrInfos=pmsBaseAttrInfoMapper.selectAttrValueListByValueId(valueIdStr);
    return pmsBaseAttrInfos;
}
</code></pre>
<p>PmsBaseAttrInfoMapper.java:</p>
<pre><code class="language-java">public interface PmsBaseAttrInfoMapper extends Mapper&lt;PmsBaseAttrInfo&gt; {
    List&lt;PmsBaseAttrInfo&gt; selectAttrValueListByValueId(@Param(&quot;valueIdStr&quot;) String valueIdStr);
}
</code></pre>
<p>PmsBaseAttrInfoMapper.xml:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.atguigu.gmall.manage.mapper.PmsBaseAttrInfoMapper&quot;&gt;
    &lt;select id=&quot;selectAttrValueListByValueId&quot; resultMap=&quot;selectAttrValueListByValueIdMap&quot;&gt;
        SELECT
            ba.*,ba.id as ba_id,bv.*,bv.id as bv_id
        FROM
            pms_base_attr_info ba,
            pms_base_attr_value bv
        WHERE
            ba.id = bv.attr_id
        AND bv.id IN (${valueIdStr})
    &lt;/select&gt;
    
    &lt;resultMap id=&quot;selectAttrValueListByValueIdMap&quot; type=&quot;com.atguigu.gmall.bean.PmsBaseAttrInfo&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;ba_id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;attrValueList&quot; ofType=&quot;com.atguigu.gmall.bean.PmsBaseAttrValue&quot; autoMapping=&quot;true&quot;&gt;
            &lt;result column=&quot;bv_id&quot; property=&quot;id&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<p>完成：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200223234320132.png" alt="image-20200223234320132"></p>
</li>
</ol>
<h5 id="13-属性列表和面包屑的url"><a class="header-anchor" href="#13-属性列表和面包屑的url">¶</a>13.属性列表和面包屑的url</h5>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200224094713717.png" alt="image-20200224094713717"></p>
<p>属性：当前url中所包含的属性值=面包屑中所包含的属性值<br>
属性列表：是排除了当前面包屑请求后的剩余属性（剩余属性=商品SKU中抽取总属性 - 当前面包屑中包含属性）</p>
<p><strong>点击属性列表中的某项属性：当前url将拼接上被点击属性构造新的请求url</strong></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200224120322854.png" alt="image-20200224120322854"></p>
<p>当前请求的url的参数就是pmsSearchParam所提交的参数</p>
<p><strong>点击面包屑：当前url将减去被点击面包屑属性构造新的url</strong></p>
<p>面包屑：用户所点击过的平台属性（属性列表中已被排除的属性），可从当前请求url中获取</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200224181605608.png" alt="image-20200224181605608"></p>
<p><strong>面包屑及属性列表制作代码：</strong></p>
<pre><code class="language-java">//剔除已选中属性以构造属性列表，同时将已选中属性制成面包屑
String[] delValueIds=pmsSearchParam.getValueId();       //已被选中的属性值
if (delValueIds!=null){
    //面包屑集
    List&lt;PmsSearchCrumb&gt; pmsSearchCrumbs=new ArrayList&lt;&gt;();
    for (String delValueId : delValueIds) {
        Iterator&lt;PmsBaseAttrInfo&gt; iterator=pmsBaseAttrInfos.iterator();
        PmsSearchCrumb pmsSearchCrumb=new PmsSearchCrumb();//面包屑参数
        pmsSearchCrumb.setValueId(delValueId);             //面包屑的属性值（id）
        pmsSearchCrumb.setUrlParam(getUrlParam(pmsSearchParam,delValueId));//面包屑的跳转链接参数
        while (iterator.hasNext()){
            PmsBaseAttrInfo pmsBaseAttrInfo = iterator.next();
            List&lt;PmsBaseAttrValue&gt; attrValueList = pmsBaseAttrInfo.getAttrValueList();
            //从属性全集中剔除已选中的属性
            for (PmsBaseAttrValue pmsBaseAttrValue : attrValueList) {
                if (pmsBaseAttrValue.getId().equals(delValueId)){
                    pmsSearchCrumb.setValueName(pmsBaseAttrValue.getValueName());//面包屑的属性值名称
                    iterator.remove();
                }
            }
        }
        pmsSearchCrumbs.add(pmsSearchCrumb);
    }
    //将面包屑集返回到前台
    modelMap.put(&quot;attrValueSelectedList&quot;,pmsSearchCrumbs);
}
String urlParam=getUrlParam(pmsSearchParam);
//将已剔除选中属性的属性列表返回到前台
modelMap.put(&quot;urlParam&quot;,urlParam);
</code></pre>
<p>由请求参数构造请求链接：</p>
<pre><code class="language-java">//由请求参数构造请求链接url
private String getUrlParam(PmsSearchParam pmsSearchParam,String ...delValueId) {
    String keyword=pmsSearchParam.getKeyword();
    String catalog3Id = pmsSearchParam.getCatalog3Id();
    String[] skuAttrValueList = pmsSearchParam.getValueId();
    StringBuilder urlParam= new StringBuilder();

    //keyword和catalog3Id中必有一个不为空
    if (StringUtils.isNotBlank(keyword)){
        if (StringUtils.isNotBlank(urlParam.toString())){
            urlParam.append(&quot;&amp;&quot;);
        }
        urlParam.append(&quot;keyword=&quot;).append(keyword);
    }
    if (StringUtils.isNotBlank(catalog3Id)){
        if (StringUtils.isNotBlank(urlParam.toString())){
            urlParam.append(&quot;&amp;&quot;);
        }
        urlParam.append(&quot;catalog3Id&quot;).append(catalog3Id);
    }
    if (skuAttrValueList!=null){
        for (String pmsSkuAttrValue : skuAttrValueList) {
            if (delValueId.length&gt;0){
                //面包屑的请求url的参数，该url需剔除被点击面包屑所包含的属性值
                if (!pmsSkuAttrValue.equals(delValueId[0])){
                    urlParam.append(&quot;&amp;valueId=&quot;).append(pmsSkuAttrValue);
                }
            }else {
                //普通请求url的参数
                urlParam.append(&quot;&amp;valueId=&quot;).append(pmsSkuAttrValue);
            }
        }
    }
    return urlParam.toString();
}
</code></pre>
<h3 id="P153购物车"><a class="header-anchor" href="#P153购物车">¶</a>P153购物车</h3>
<p>流程：在用户未登录时也可以使用购物车功能，某些系统（如淘宝）也会要求用户必须登录才能使用购物车。</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200225221954372.png" alt="image-20200225221954372"></p>
<p>我们配一下本地的host文件，同时对以往html的url做一些更新。</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200226143426431.png" alt="image-20200226143426431"></p>
<h4 id="谷粒购物车"><a class="header-anchor" href="#谷粒购物车">¶</a>谷粒购物车</h4>
<p>购物车业务比较简单，我们新建gmall-cart-web和gmall-cart-service两个模块，设置对应配置，引入对应的依赖。然后在gmall-cart-web模块中粘贴好购物车的前端静态资源文件</p>
<p>修改一下商品详情页中的购物车跳转地址：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200225184816359.png" alt="image-20200225184816359"></p>
<p>跳转方式：重定向到购物车页面</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200225184332132.png" alt="image-20200225184332132"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200225202541206.png" alt="image-20200225202541206"></p>
<h5 id="1-介绍"><a class="header-anchor" href="#1-介绍">¶</a>1.介绍</h5>
<ol>
<li>
<p>购物车在不登录时也能使用</p>
<p>需要引入对浏览器cookie的操作</p>
</li>
<li>
<p>购物车在登录时要用mysql和redis来存储数据，</p>
<p>redis作为购物车的缓存</p>
</li>
<li>
<p>在缓存情况下，或者用户已经添加购物车后，允许购物车中的数据和原始商品数据不一致</p>
</li>
<li>
<p>购物车同步问题</p>
<p>什是时候同步：结算&amp;登录时同步</p>
<p>同步后是否需要删除cookie数据</p>
</li>
<li>
<p>用户在不同的客户端同时登录</p>
<p>如何处理购物车数据</p>
</li>
</ol>
<h5 id="2-购物车添加商品功能"><a class="header-anchor" href="#2-购物车添加商品功能">¶</a>2.购物车添加商品功能</h5>
<ol>
<li>
<p>传递参数：商品skuId，添加数量quantity</p>
</li>
<li>
<p>根据skuid调用skuService查询商品的详细信息</p>
</li>
<li>
<p>将商品详细信息封装成购物车信息</p>
</li>
<li>
<p>判断用户是否登录</p>
</li>
<li>
<p>根据用户登录状态决定走cookie分支还是db分支，对购物车数据进行写入操作：</p>
<p>Cookies存取：response.addCookie(cookie)，request.getCookies()<br>
Cookies的跨域问题：setDomain()，getDomain()</p>
<p>Db+cache</p>
<p>我们在web-util模块下写一个工具类来处理与Cookie相关的操作</p>
<pre><code class="language-java">import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
/**
 * @param
 * @return
 */
public class CookieUtil {
    /***
     * 获得cookie中的值，默认为主ip：www.gmall.com
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) {
        Cookie[] cookies = request.getCookies();
        if (cookies == null || cookieName == null){
            return null;
        }
        String retValue = null;
        try {
            for (int i = 0; i &lt; cookies.length; i++) {
                if (cookies[i].getName().equals(cookieName)) {
                    if (isDecoder) {//如果涉及中文
                        retValue = URLDecoder.decode(cookies[i].getValue(), &quot;UTF-8&quot;);
                    } else {
                        retValue = cookies[i].getValue();
                    }
                    break;
                }
            }
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return retValue;
    }
    /***
     * 设置cookie的值
     */
    public static   void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) {
        try {
            if (cookieValue == null) {
                cookieValue = &quot;&quot;;
            } else if (isEncode) {
                cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
            }
            Cookie cookie = new Cookie(cookieName, cookieValue);
            if (cookieMaxage &gt;= 0)
                cookie.setMaxAge(cookieMaxage);
            if (null != request)// 设置域名的cookie
                cookie.setDomain(getDomainName(request));
            // 在域名的根路径下保存
            cookie.setPath(&quot;/&quot;);
            response.addCookie(cookie);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /***
     * 获得cookie的主域名，本系统为gmall.com，保存时使用
     */
    private static final String getDomainName(HttpServletRequest request) {
        String domainName = null;
        String serverName = request.getRequestURL().toString();
        if (serverName == null || serverName.equals(&quot;&quot;)) {
            domainName = &quot;&quot;;
        } else {
            serverName = serverName.toLowerCase();
            serverName = serverName.substring(7);
            final int end = serverName.indexOf(&quot;/&quot;);
            serverName = serverName.substring(0, end);
            final String[] domains = serverName.split(&quot;\\.&quot;);
            int len = domains.length;
            if (len &gt; 3) {
                // www.xxx.com.cn
                domainName = domains[len - 3] + &quot;.&quot; + domains[len - 2] + &quot;.&quot; + domains[len - 1];
            } else if (len &lt;= 3 &amp;&amp; len &gt; 1) {
                // xxx.com or xxx.cn
                domainName = domains[len - 2] + &quot;.&quot; + domains[len - 1];
            } else {
                domainName = serverName;
            }
        }
        if (domainName != null &amp;&amp; domainName.indexOf(&quot;:&quot;) &gt; 0) {
            String[] ary = domainName.split(&quot;\\:&quot;);
            domainName = ary[0];
        }
        System.out.println(&quot;domainName = &quot; + domainName);
        return domainName;
    }
    /***
     * 将cookie中的内容按照key删除
     */
    public static void deleteCookie(HttpServletRequest request, HttpServletResponse response, String cookieName) {
        setCookie(request, response, cookieName, null, 0, false);
    }
}
</code></pre>
</li>
<li>
<p>购物车类型：</p>
<p>DB：cartListDb （有主键和用户id）<br>
Cookie：cartListCookie（没有主键和用户id）<br>
Redis：cartListCache（有主见和用户id）</p>
</li>
</ol>
<h5 id="3-购物车的缓存结构"><a class="header-anchor" href="#3-购物车的缓存结构">¶</a>3.购物车的缓存结构</h5>
<ol>
<li>
<p>存储的是购物车集合</p>
</li>
<li>
<p>键：用户id</p>
</li>
<li>
<p>购物车缓存中某一个购物车数据的更新</p>
<p><s>用set kv 取出json，转换成集合，从集合中取出对象，修改对象，放回集合，在将集合放回缓存</s>（麻烦）</p>
<p>用hashMap结构来存储购物车：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200226164506909.png" alt="image-20200226164506909"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200226164719260.png" alt="image-20200226164719260"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200226171318143.png" alt="image-20200226171318143"></p>
<p>实现：</p>
<pre><code class="language-java">@Override
public void flushCartCache(String memberId) {
    OmsCartItem omsCartItem=new OmsCartItem();
    omsCartItem.setMemberId(memberId);
    List&lt;OmsCartItem&gt; cartItems = omsCartItemMapper.select(omsCartItem);
    //同步到redis缓存
    Jedis jedis = redisUtil.getJedis();
    Map&lt;String,String&gt; map=new HashMap&lt;&gt;();
    for (OmsCartItem cartItem : cartItems) {
        map.put(cartItem.getProductSkuId(), JSON.toJSONString(cartItem));
    }
    jedis.hmset(&quot;user:&quot;+memberId+&quot;:cart&quot;,map);
    jedis.close();
}
</code></pre>
</li>
</ol>
<h5 id="4-购物车列表"><a class="header-anchor" href="#4-购物车列表">¶</a>4.购物车列表</h5>
<ol>
<li>
<p>购物车列表数据从缓存中取</p>
</li>
<li>
<p>购物车页面展示<img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200226201751723.png" alt="image-20200226201751723"></p>
</li>
<li>
<p>购物车异步修改选中状态</p>
<p>A）异步请求：返回json，也可返回内嵌页面。我们采用返回内嵌页面的方式刷新购物车列表<br>
B）修改数据库中购物车状态<br>
C）数据库修改后同步缓存</p>
<pre><code class="language-javascript">//cartList.html 异步请求
function checkSku( chkbox){
    var skuId= $(chkbox).attr(&quot;value&quot;);
    var checked=$(chkbox).prop(&quot;checked&quot;);
    var isCheckedFlag=&quot;0&quot;;
    if(checked){
        isCheckedFlag=&quot;1&quot;;
    }
    var param=&quot;isChecked=&quot;+isCheckedFlag+&quot;&amp;&quot;+&quot;skuId=&quot;+skuId;
    $.post(&quot;checkCart&quot;,param,function (data) {
        sumSumPrice();
        //服务器会返回一个内嵌页面给ajax，我们用新的页面刷新替换掉原来的老页面
        $(&quot;#cartListInner&quot;).html(data);
    });
}
</code></pre>
</li>
<li>
<p>价格计算：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200227153017658.png" alt="image-20200227153017658"></p>
<p>涉及到价格计算时应当用<strong>BigDecimal</strong>做运算、比较，并用字符串初始化</p>
</li>
</ol>
<h5 id="5-代码实现："><a class="header-anchor" href="#5-代码实现：">¶</a>5.代码实现：</h5>
<p>CartController：</p>
<pre><code class="language-java">@Controller
public class CartController {

    @Reference
    SkuService skuService;

    @Reference
    CartService cartService;

    @RequestMapping(&quot;checkCart&quot;)
    public String checkCart(String isChecked,String skuId,ModelMap modelMap){
        String memberId=&quot;1&quot;;
        //调用服务，修改状态
        OmsCartItem omsCartItem = new OmsCartItem();
        omsCartItem.setMemberId(memberId);
        omsCartItem.setIsChecked(isChecked);
        omsCartItem.setProductSkuId(skuId);
        cartService.checkCart(omsCartItem);
        //将最新数据从缓存中取出，渲染给内嵌页面
        List&lt;OmsCartItem&gt; omsCartItems = cartService.cartList(memberId);
        //设置购物车单项总价，并计算选中商品总价
        BigDecimal totalAmount=calculatePrice(omsCartItems);
        //购物车商品列表
        modelMap.put(&quot;cartList&quot;,omsCartItems);
        //购物车总价
        modelMap.put(&quot;totalAmount&quot;,totalAmount);
        return &quot;cartListInner&quot;;
    }

    @RequestMapping(&quot;cartList&quot;)
    public String cartList(HttpServletRequest request, ModelMap modelMap){
        List&lt;OmsCartItem&gt; omsCartItems = null;
        String userId=&quot;1&quot;;
        if (StringUtils.isNotBlank(userId)){
            //已经登录,查询db
            omsCartItems=cartService.cartList(userId);
        }else {
            //没有登录查询Cookie
            String cartListCookie = CookieUtil.getCookieValue(request, &quot;cartListCookie&quot;, true);
            if (StringUtils.isNotBlank(cartListCookie)){
                omsCartItems=JSON.parseArray(cartListCookie,OmsCartItem.class);
            }
        }
        //设置购物车单项总价，并计算选中商品总价
        assert omsCartItems != null;
        BigDecimal totalAmount=calculatePrice(omsCartItems);
        //购物车商品列表
        modelMap.put(&quot;cartList&quot;,omsCartItems);
        //购物车总价
        modelMap.put(&quot;totalAmount&quot;,totalAmount);
        return &quot;cartList&quot;;
    }

    @RequestMapping(&quot;addToCart&quot;)
    public String addToCart(String skuId, int quantity, HttpServletRequest request, HttpServletResponse response){
        //调用商品服务查询商品信息
        PmsSkuInfo skuInfo = skuService.getSkuById(skuId);

        List&lt;OmsCartItem&gt; omsCartItems;

        //将商品封装成购物车信息
        OmsCartItem omsCartItem=new OmsCartItem();
        omsCartItem.setCreateDate(new Date());
        omsCartItem.setModifyDate(omsCartItem.getCreateDate());
        omsCartItem.setDeleteStatus(0);
        omsCartItem.setPrice(skuInfo.getPrice());
        omsCartItem.setProductAttr(&quot;&quot;);
        omsCartItem.setProductBrand(&quot;&quot;);
        omsCartItem.setProductCategoryId(skuInfo.getCatalog3Id());
        omsCartItem.setProductId(skuInfo.getProductId());
        omsCartItem.setProductName(skuInfo.getSkuName());
        omsCartItem.setProductPic(skuInfo.getSkuDefaultImg());
        omsCartItem.setProductSkuCode(&quot;11111&quot;);
        omsCartItem.setProductSkuId(skuId);
        omsCartItem.setQuantity(quantity);
        omsCartItem.setIsChecked(&quot;1&quot;);

        //判断用户是否登录
        String memberId=&quot;1&quot;;

        if (StringUtils.isBlank(memberId)){
            //用户未登录
            //取出cookie里原有的购物车数据
            String cartListCookie = CookieUtil.getCookieValue(request, &quot;cartListCookie&quot;, true);

            if (StringUtils.isBlank(cartListCookie)){
                //购物车cookie为空
                omsCartItems=new ArrayList&lt;&gt;();
                omsCartItems.add(omsCartItem);
            }else {
                //购物车cookie不为空
                omsCartItems = JSON.parseArray(cartListCookie,OmsCartItem.class);
                //判断添加到购物车的商品数据在cookie中是否存在
                OmsCartItem exist=if_cart_exist(omsCartItems,omsCartItem);
                if (exist!=null){
                    //之前添加过，更新购物车中该商品的数量
                    exist.setQuantity(exist.getQuantity()+omsCartItem.getQuantity());
                }else {
                    //之前没有添加过，新增该商品到当前购物车
                    omsCartItems.add(omsCartItem);
                }
            }
            //更新cookie
            CookieUtil.setCookie(request,response,&quot;cartListCookie&quot;,
                    JSON.toJSONString(omsCartItems),3600*72,true);
        }else {
            //用户已登录
            OmsCartItem cartItemFromDb=cartService.ifItemExistsInUserCart(memberId,skuId);
            if (cartItemFromDb==null){
                //该用户未添加过此商品
                omsCartItem.setMemberId(memberId);
                omsCartItem.setQuantity(quantity);
                omsCartItem.setMemberNickname(&quot;测试啊&quot;);
                cartService.addCartItem(omsCartItem);
            }else {
                //该用户已添加此商品
                cartItemFromDb.setQuantity(cartItemFromDb.getQuantity()+omsCartItem.getQuantity());
                cartService.updateCart(cartItemFromDb);
            }
            //同步缓存
            cartService.flushCartCache(memberId);
        }

        return &quot;redirect:/success.html&quot;;
    }

    /**
     * 判断购物车中是否已存在相同商品，若存在则返回该购物车中商品项，否则返回null
     * @param omsCartItems 购物车中已有商品
     * @param omsCartItem 待判断是否存在于购物车的商品
     * @return 购物车中已存在的相同商品
     */
    private OmsCartItem if_cart_exist(List&lt;OmsCartItem&gt; omsCartItems, OmsCartItem omsCartItem) {
        for (OmsCartItem cartItem : omsCartItems) {
            if (cartItem.getProductSkuId().equals(omsCartItem.getProductSkuId())){
                return cartItem;
            }
        }
        return null;
    }

    /**
     * 设置购物车中单项商品的总价，并返回购物车内选中商品的总价
     * @param omsCartItems 购物车商品列表
     * @return 购物车商品总价
     */
    private BigDecimal calculatePrice(List&lt;OmsCartItem&gt; omsCartItems){
        BigDecimal totalAmount=new BigDecimal(&quot;0&quot;);
        for (OmsCartItem omsCartItem : omsCartItems) {
            //计算单品总价
            omsCartItem.setTotalPrice(omsCartItem.getPrice().multiply(BigDecimal.valueOf(omsCartItem.getQuantity())));
            //若被选中，累加入购物车选中商品总价
            if (omsCartItem.getIsChecked().equals(&quot;1&quot;)){
                totalAmount=totalAmount.add(omsCartItem.getTotalPrice());
            }
        }
        return totalAmount;
    }
}
</code></pre>
<p>CartServiceImpl:</p>
<pre><code class="language-java">@Service
public class CartServiceImpl implements CartService {

    @Autowired
    RedisUtil redisUtil;

    @Autowired
    OmsCartItemMapper omsCartItemMapper;

    @Override
    public OmsCartItem ifItemExistsInUserCart(String memberId, String skuId) {
        OmsCartItem omsCartItem=new OmsCartItem();
        omsCartItem.setMemberId(memberId);
        omsCartItem.setProductSkuId(skuId);
        OmsCartItem selectOne = omsCartItemMapper.selectOne(omsCartItem);
        return selectOne;
    }

    @Override
    public void addCartItem(OmsCartItem omsCartItem) {
        if (StringUtils.isNotBlank(omsCartItem.getMemberId())){
            omsCartItemMapper.insert(omsCartItem);
        }
    }

    @Override
    public void updateCart(OmsCartItem cartItemFromDb) {
        Example example=new Example(OmsCartItem.class);
        example.createCriteria().andEqualTo(&quot;id&quot;,cartItemFromDb.getId());
        omsCartItemMapper.updateByExampleSelective(cartItemFromDb,example);
    }

    @Override
    public void flushCartCache(String memberId) {
        OmsCartItem omsCartItem=new OmsCartItem();
        omsCartItem.setMemberId(memberId);
        List&lt;OmsCartItem&gt; cartItems = omsCartItemMapper.select(omsCartItem);
        //同步到redis缓存
        Jedis jedis = redisUtil.getJedis();
        Map&lt;String,String&gt; map=new HashMap&lt;&gt;();
        for (OmsCartItem cartItem : cartItems) {
            map.put(cartItem.getProductSkuId(), JSON.toJSONString(cartItem));
        }
        jedis.del(&quot;user:&quot;+memberId+&quot;:cart&quot;);
        jedis.hmset(&quot;user:&quot;+memberId+&quot;:cart&quot;,map);
        jedis.close();
    }

    @Override
    public List&lt;OmsCartItem&gt; cartList(String userId) {
        Jedis jedis = redisUtil.getJedis();
        List&lt;OmsCartItem&gt; omsCartItems = new ArrayList&lt;&gt;();
        //就自己访问，我觉得应该不用加锁
        List&lt;String&gt; hvals = jedis.hvals(&quot;user:&quot; + userId + &quot;:cart&quot;);
        for (String hval : hvals) {
            OmsCartItem omsCartItem = JSON.parseObject(hval, OmsCartItem.class);
            omsCartItems.add(omsCartItem);
        }
        jedis.close();
        return omsCartItems;
    }

    @Override
    public void checkCart(OmsCartItem omsCartItem) {
        Example example=new Example(OmsCartItem.class);
        example.createCriteria().andEqualTo(&quot;memberId&quot;,omsCartItem.getMemberId())
                .andEqualTo(&quot;productSkuId&quot;,omsCartItem.getProductSkuId());
        omsCartItemMapper.updateByExampleSelective(omsCartItem,example);
        //同步缓存
        flushCartCache(omsCartItem.getMemberId());
    }
}
</code></pre>
<h4 id="题外话——Dubbo服务端口绑定报错问题："><a class="header-anchor" href="#题外话——Dubbo服务端口绑定报错问题：">¶</a>题外话——Dubbo服务端口绑定报错问题：</h4>
<pre><code class="language-sh">2020-02-27 00:56:21.194 ERROR 24316 --- [           main] com.alibaba.dubbo.qos.server.Server      :  [DUBBO] qos-server can not bind localhost:22222, dubbo version: 2.6.0, current host: 127.0.0.1

java.net.BindException: Address already in use: bind
	at sun.nio.ch.Net.bind0(Native Method) ~[na:1.8.0_161]
	at sun.nio.ch.Net.bind(Net.java:433) ~[na:1.8.0_161]
	at sun.nio.ch.Net.bind(Net.java:425) ~[na:1.8.0_161]
	at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223) ~[na:1.8.0_161]
	at io.netty.channel.socket.nio.NioServerSocketChannel.doBind(NioServerSocketChannel.java:130) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.bind(AbstractChannel.java:563) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.bind(DefaultChannelPipeline.java:1332) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeBind(AbstractChannelHandlerContext.java:488) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.channel.AbstractChannelHandlerContext.bind(AbstractChannelHandlerContext.java:473) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.channel.DefaultChannelPipeline.bind(DefaultChannelPipeline.java:984) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.channel.AbstractChannel.bind(AbstractChannel.java:259) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.bootstrap.AbstractBootstrap$2.run(AbstractBootstrap.java:366) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
	at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_161]
</code></pre>
<p>试过，以下设置没用：</p>
<pre><code class="language-properties"># 手动分配dubbo协议端口号
spring.dubbo.protocol.port=44445
</code></pre>
<h3 id="P167-用户认证Passport"><a class="header-anchor" href="#P167-用户认证Passport">¶</a>P167 用户认证Passport</h3>
<h5 id="1-介绍-v2"><a class="header-anchor" href="#1-介绍-v2">¶</a>1.介绍</h5>
<ol>
<li>在购物车之前的功能，不要求用户登录判断</li>
<li>在购物车之后的功能，必须要求用户登录的判断通过</li>
<li>购物车功能中，必须对用户登录进行判定，判定失败也可继续使用（采用Cookie购物车）</li>
</ol>
<h5 id="2-用户认证模块的设计："><a class="header-anchor" href="#2-用户认证模块的设计：">¶</a>2.用户认证模块的设计：</h5>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200227175419584.png" alt="image-20200227175419584"></p>
<h5 id="3-认证中心"><a class="header-anchor" href="#3-认证中心">¶</a>3. 认证中心</h5>
<pre><code>1. 给用户颁发通信证（ttoken）
2. 验证其他业务功能接收token（用户访问所携带的）的真伪
</code></pre>
<p><strong>整合：</strong></p>
<ol>
<li>
<p>引入静态资源</p>
</li>
<li>
<p>在search模块的页面点击登录连接上加上认证中心的url</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228002033022.png" alt="image-20200228002033022"></p>
</li>
<li>
<p>增加一个测试用的结算功能页面（真正的结算功能开发在订单模块）</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228002242876.png" alt="image-20200228002242876"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228002350740.png" alt="image-20200228002350740"></p>
</li>
<li>
<p>加入拦截器（在web-util模块中加入拦截器，让所有请求到web服务的请求都被拦截器拦截）</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228144210465.png" alt="image-20200228144210465"></p>
<pre><code class="language-java">@Configuration
public class WebMvcConfiguration extends WebMvcConfigurerAdapter {
    @Autowired
    AuthInterceptor authInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry){
        registry.addInterceptor(authInterceptor).addPathPatterns(&quot;/**&quot;);
        super.addInterceptors(registry);
    }
}
</code></pre>
<pre><code class="language-java">@Component
public class AuthInterceptor extends HandlerInterceptorAdapter {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //拦截代码
        return true;
    }
}
</code></pre>
</li>
<li>
<p>决定模块是否被拦截器拦截</p>
<p>除了可以通过web模块是否扫描拦截器来决定拦截器的使用之外</p>
<p>还可以通过注解的方式来标识具体的方法是否需要通过拦截器：@LoginRequired</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228145921264.png" alt="image-20200228145921264"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228145959115.png" alt="image-20200228145959115"></p>
<p>该注解只对方法有效，生效范围是运行时生效</p>
<p>利用反射机制（通过一个对象获得类的整体信息），用所请求方法的方法名去得到方法信息</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LoginRequired {
    boolean loginSuccessNeeded() default true;
}
</code></pre>
<p>我们可以将被请求方法分为三类：</p>
<ul>
<li>不需要拦截器（没有拦截器注解），直接放行，<strong>不用加上@LoginRequired</strong></li>
<li>需要拦截器但拦截校验失败（未登录或登录已过期）也可继续访问的方法，这些方法通常要视登录与否决定方法具体的执行逻辑，如购物车中的所有方法，<strong>@LoginRequired(loginSuccessNeeded=false)</strong></li>
<li>需要拦截，并且拦截校验一定要通过（登录成功）才能访问的方法，<strong>@LoginRequired</strong></li>
</ul>
</li>
</ol>
<h5 id="4-单点登录（Single-Sign-On，SSO）"><a class="header-anchor" href="#4-单点登录（Single-Sign-On，SSO）">¶</a>4.单点登录（Single Sign On，SSO）</h5>
<p>​	将用户登录认证中心抽离出来，只要在一个模块登录了，在进入其他业务模块（不管是属于顶级域名下的还是跨越了顶级域名）也已经登录了，不需要二次登录。</p>
<p>单点登录服务介绍：</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/av55643074?p=174" target="_blank" rel="noopener">https://www.bilibili.com/video/av55643074?p=174</a></p>
</blockquote>
<ol>
<li>
<p>早期：单一服务器，用户认证；缺点：单点性能压力，无法扩展</p>
</li>
<li>
<p>Web应用集群，session共享模式</p>
<p>通过JsessionId判断用户是否已登录</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228162347274.png" alt="image-20200228162347274"></p>
<p>解决了单点性能瓶颈<br>
问题：</p>
<ul>
<li>多业务分布式数据独立管理，不适合统一维护一份session数据</li>
<li>分布式按业务功能切分，用户、认证解耦出来单独统一管理</li>
<li>cookie中使用jsessionId容易被篡改、盗取</li>
<li>跨顶级域名无法访问</li>
</ul>
</li>
<li>
<p>分布式，SSO模式</p>
<p>Jwt+userInfo 在认证中心解密校验来判断是否登录，采用Jwt加密算法保障安全，避免了访问Redis或DB</p>
</li>
</ol>
<h5 id="5-用JWT实现用户登录的校验（token）"><a class="header-anchor" href="#5-用JWT实现用户登录的校验（token）">¶</a>5.用JWT实现用户登录的校验（token）</h5>
<p>JWT工具：</p>
<p>JWT（Json Web Token） 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。<br>
JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上<br>
JWT 最重要的作用就是对 token信息的防伪作用。</p>
<p>JWT的原理：</p>
<p>一个JWT由三个部分组成：公共部分、私有部分、签名部分。最后由这三者组合进行base64编码得到JWT。</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228172157695.png" alt="image-20200228172157695"></p>
<p>公共部分：主要是该JWT的相关配置参数，比如签名的加密算法、格式类型、过期时间等等。<br>
私有部分：用户自定义的内容，根据实际需要真正要封装的信息。<br>
签名部分：根据用户信息+盐值+密钥生成的签名。如果想知道JWT是否是真实的只要把JWT的信息取出来，加上盐值和服务器中的密钥就可以验证真伪。所以不管由谁保存JWT，只要没有密钥就无法伪造。<br>
base64编码，并不是加密，只是把明文信息变成了不可见的字符串。但是其实只要用一些工具就可以吧base64编码解成明文，所以不要在JWT中放入涉及私密的信息，因为实际上JWT并不是加密信息。</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228173119491.png" alt="image-20200228173119491"></p>
<p>在web-util引入pom依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
    &lt;version&gt;0.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>制作JWT的工具类：</p>
<pre><code class="language-java">public class JwtUtil {
    public static String encode(String key,Map&lt;String,Object&gt; param,String salt){
        if(salt!=null){
            key+=salt;
        }
        JwtBuilder jwtBuilder = Jwts.builder().signWith(SignatureAlgorithm.HS256,key);

        jwtBuilder = jwtBuilder.setClaims(param);

        String token = jwtBuilder.compact();
        return token;

    }
    public  static Map&lt;String,Object&gt;  decode(String token ,String key,String salt){
        Claims claims=null;
        if (salt!=null){
            key+=salt;
        }
        try {
            claims= Jwts.parser().setSigningKey(key).parseClaimsJws(token).getBody();
        } catch ( JwtException e) {
           return null;
        }
        return  claims;
    }
}
</code></pre>
<p>使用示例：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228173541230.png" alt="image-20200228173541230"></p>
<h5 id="6-passport登录功能"><a class="header-anchor" href="#6-passport登录功能">¶</a>6.passport登录功能</h5>
<ol>
<li>
<p>点击登录按钮，在登录页面输入用户名密码，通过用户名密码验证用户是否登录成功，<a href="http://xn--JWTtokensearch-7z4y932k1y5dseao87q778d.gmall.com/index%EF%BC%8C%E5%9C%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%AD%E5%B0%86%E8%BF%94%E5%9B%9E%E7%9A%84token%E5%86%99%E5%85%A5cookie" target="_blank" rel="noopener">用JWT生成token返回给search.gmall.com/index，在拦截器中将返回的token写入cookie</a></p>
</li>
<li>
<p>点击结算按钮，拦截器拦截请求</p>
<p>该用户没有登录，并且结算请求时必须登录，将用户打回认证中心进行登录</p>
<p>该用户没有登录，并且请求时没登录也可访问，放行</p>
</li>
<li>
<p>被拦截登录后，返回原始请求（携带登录成功后颁发的token）</p>
</li>
<li>
<p>原始请求的拦截器第二次拦截请求，拦截请求后，将返回的token写入cookie</p>
</li>
</ol>
<h5 id="7-从首页点击登录的流程"><a class="header-anchor" href="#7-从首页点击登录的流程">¶</a>7.从首页点击登录的流程</h5>
<ol>
<li>
<p>首页访问登录页，携带ReturnUrl回跳地址</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228204246925.png" alt="image-20200228204246925"></p>
<ol start="2">
<li>登录页保存回跳地址</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228204432422.png" alt="image-20200228204432422"></p>
<ol start="3">
<li>登录页通过异步方式验证用户名密码</li>
</ol>
<pre><code class="language-html">&lt;form id=&quot;loginForm&quot; action=&quot;./login&quot; method=&quot;post&quot;&gt;
</code></pre>
<pre><code class="language-javascript">//异步提交
function submitLogin() {
    const username = $(&quot;#username&quot;).val();
    const password = $(&quot;#password&quot;).val();
    $.post(&quot;login&quot;,{username:username,password:password},function (token) {
        alert(token);
        //验证token是否为空或者异常
...
        window.location.href=$(&quot;#ReturnUrl&quot;).val()+&quot;?token=&quot;+token;
    })
}
</code></pre>
<ol start="4">
<li>验证通过后颁发token给异步ajax</li>
</ol>
<pre><code class="language-java">public class PassportController {
    @RequestMapping(&quot;index&quot;)
    public String index(String ReturnUrl, ModelMap modelMap){
        modelMap.put(&quot;ReturnUrl&quot;,ReturnUrl);
        return &quot;index&quot;;
    }

    @RequestMapping(&quot;login&quot;)
    @ResponseBody
    public String login(UmsMember umsMember){
        //调用用户服务验证用户名和密码

        return &quot;token&quot;;
    }
}
</code></pre>
<ol start="5">
<li>异步ajax得到token，根据回跳地址ReturnUrl请求原始功能</li>
</ol>
<pre><code class="language-javascript">window.location.href=$(&quot;#ReturnUrl&quot;).val()+&quot;?token=&quot;+token;
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228211310148.png" alt="image-20200228211310148"></p>
</li>
</ol>
<h5 id="8-拦截器开发"><a class="header-anchor" href="#8-拦截器开发">¶</a>8.拦截器开发</h5>
<p>拦截请求的流程：</p>
<ol>
<li>
<p>被拦截器拦截</p>
</li>
<li>
<p>拦截器判断注解</p>
<ul>
<li>是否需要登录验证（是否有@LoginRequired注解）</li>
<li>是否必须能录才能请求（loginSuccessNeeded==true?）</li>
</ul>
<p>拦截器拦截token的四种情况：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200228220821687.png" alt="image-20200228220821687"></p>
<p>必须登录但没登录时，会被重定向到认证中心进行登录</p>
<p>在认证中心登录后，会重新请求原始应用</p>
</li>
<li>
<p>验证</p>
<p>通过Httpclient（apache的一个通用工具类）</p>
</li>
<li>
<p>结合注解的情况验证结果</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200229012606430.png" alt="image-20200229012606430"></p>
<p>注意：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200229150212194.png" alt="image-20200229150212194"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200229150523914.png" alt="image-20200229150523914"></p>
<h5 id="9-用户UserService服务的对接"><a class="header-anchor" href="#9-用户UserService服务的对接">¶</a>9.用户UserService服务的对接</h5>
<ol>
<li>
<p>认证中心调用用户服务进行login和信息的查询</p>
</li>
<li>
<p>用户服务可调用缓存</p>
<p>User:username:password + user:memberId:info (这种做法麻烦)</p>
<p>user:password（加密并拼接username等等）:info</p>
</li>
</ol>
<h4 id="代码实现："><a class="header-anchor" href="#代码实现：">¶</a>代码实现：</h4>
<p>AuthInterceptor.java</p>
<pre><code class="language-java">@Component
public class AuthInterceptor extends HandlerInterceptorAdapter {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //拦截代码:

        //判断被拦截请求所访问的方法的注解（是否是需要拦截的）
        HandlerMethod hm=(HandlerMethod)handler;
        LoginRequired methodAnnotation = hm.getMethodAnnotation(LoginRequired.class);
        if (methodAnnotation==null){
            return true;
        }

        String token=&quot;&quot;;
        String oldToken = CookieUtil.getCookieValue(request, &quot;oldToken&quot;, true);
        if (StringUtils.isNotBlank(oldToken)){
            token=oldToken;
        }
        String newToekn = request.getParameter(&quot;token&quot;);
        if (StringUtils.isNotBlank(newToekn)){
            token=newToekn;
        }

        //进入拦截器的拦截方法
        boolean loginSuccessNeeded = methodAnnotation.loginSuccessNeeded(); //该请求是否必须成功登录
        String verify = &quot;&quot;;
        Map verificationMap=null;
        //获得发起请求的客户端的ip
        String ip=request.getHeader(&quot;x-forwarded-for&quot;);     //通过nginx转发的客户端ip
        if (StringUtils.isBlank(ip)){
            ip=request.getRemoteAddr();     //从request中获取ip
            if (StringUtils.isBlank(ip)){
                ip=&quot;123.123.123.123&quot;;       //异常情况，不做过多拓展
            }
        }
        //调用认证中心进行验证
        if (StringUtils.isNotBlank(token)){
            //请求认证中心进行验证，得到验证结果verificationMap
            String verifyJson=HttpclientUtil
                    .doGet(&quot;http://passport.gmall.com:8085/verify?token=&quot; + token+&quot;&amp;currentIp=&quot;+ip);
            verificationMap= JSON.parseObject(verifyJson,Map.class);
            assert verificationMap != null;
            verify= (String) verificationMap.get(&quot;status&quot;);
        }

        if (loginSuccessNeeded){
            //必须登录成功才能放行
            if (!verify.equals(&quot;success&quot;)){
                //从未登录，踢回认证中心
                response.sendRedirect(&quot;http://passport.gmall.com:8085/index?ReturnUrl=&quot;
                        +request.getRequestURL()+&quot;&amp;requestIP=&quot;+ip);
                return false;
            }else {
                //验证通过，覆盖cookie中的token
                //已登录，需要将token携带的用户信息写入
                request.setAttribute(&quot;memberId&quot;,verificationMap.get(&quot;memberId&quot;));
                request.setAttribute(&quot;nicknam&quot;,verificationMap.get(&quot;nickname&quot;));
                //验证通过，覆盖cookie中的token
                if (StringUtils.isNotBlank(token)){
                    CookieUtil.setCookie(request,response,&quot;oldToken&quot;,token,60*60*2,true);
                }
            }
        }else {
            //没登录也能用，但必须验证
            if (verify.equals(&quot;success&quot;)){
                //已登录，需要将token携带的用户信息写入
                request.setAttribute(&quot;memberId&quot;,verificationMap.get(&quot;memberId&quot;));
                request.setAttribute(&quot;nicknam&quot;,verificationMap.get(&quot;nickname&quot;));
                //验证通过，覆盖cookie中的token
                    CookieUtil.setCookie(request,response,&quot;oldToken&quot;,token,60*60*2,true);
            }
        }

        return true;
    }
}
</code></pre>
<p>PassportController.java</p>
<pre><code class="language-java">@Controller
public class PassportController {

    @Reference
    UserService userService;

    @RequestMapping(&quot;index&quot;)
    public String index(String ReturnUrl, ModelMap modelMap){
        modelMap.put(&quot;ReturnUrl&quot;,ReturnUrl);
        return &quot;index&quot;;
    }

    @RequestMapping(&quot;verify&quot;)
    @ResponseBody
    public String verify(String token,String currentIp){
        //通过JWT校验token真假

        Map&lt;String,String&gt; map=new HashMap&lt;&gt;();
        Map&lt;String, Object&gt; decode = JwtUtil.decode(token, &quot;2019gmall&quot;, currentIp);
        if (decode!=null){
            map.put(&quot;status&quot;,&quot;success&quot;);
            map.put(&quot;memberId&quot;,(String) decode.get(&quot;memberId&quot;));
            map.put(&quot;nickname&quot;,(String) decode.get(&quot;nickname&quot;));
        }else {
            map.put(&quot;status&quot;,&quot;fail&quot;);
        }
        return JSON.toJSONString(map);
    }

    @RequestMapping(&quot;login&quot;)
    @ResponseBody
    public String login(UmsMember umsMember, HttpServletRequest request){
        String token=&quot;&quot;;
        //调用用户服务验证用户名和密码
        UmsMember loginUser=userService.login(umsMember);
        if (loginUser!=null){
            //登录成功，用JWT制作token
            Map&lt;String,Object&gt; userMap=new HashMap&lt;&gt;();
            userMap.put(&quot;memberId&quot;,umsMember.getId());
            userMap.put(&quot;nickname&quot;,umsMember.getNickname());

            String ip=request.getHeader(&quot;x-forwarded-for&quot;);     //通过nginx转发的客户端ip
            if (StringUtils.isBlank(ip)){
                ip=request.getRemoteAddr();     //从request中获取ip
                if (StringUtils.isBlank(ip)){
                    ip=&quot;123.123.123.123&quot;;       //异常情况，不做过多拓展
                }
            }
            token = JwtUtil.encode(&quot;2019gmall&quot;, userMap, ip);
            //存入一份token到redis
            userService.addUserToken(token,umsMember.getId());
        }else {
            //登录失败
            token+=&quot;FAILED&quot;;
        }
        return token;
    }
}
</code></pre>
<h3 id="P190-社交登录"><a class="header-anchor" href="#P190-社交登录">¶</a>P190 社交登录</h3>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200229211819418.png" alt="image-20200229211819418"></p>
<p>流程：</p>
<ol>
<li>用户希望通过第三方平台账号登录目的平台。首先重定向到第三方平台登录界面，登录第三方平台（请求第三方平台授权目的平台使用本用户的信息）。第三方平台准许授权，返回code给用户。</li>
<li>用户拿到授权code之后将code给目的平台。</li>
<li>目的平台以用户得到的code为凭证，向第三方平台请求access_token。</li>
<li>目的平台得到access_token，以此向第三方平台的用户服务请求用户数据。</li>
</ol>
<p>自己的授权ID和授权秘钥</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200301012032849.png" alt="image-20200301012032849"></p>
<p>修改回调地址（将来需要和授权请求地址保持一致）：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200301012322431.png" alt="image-20200301012322431"></p>
<h4 id="四步完成授权操作："><a class="header-anchor" href="#四步完成授权操作：">¶</a>四步完成授权操作：</h4>
<ol>
<li>
<p>请求授权地址，用户和第三方签订授权协议</p>
<blockquote>
<p>授权地址公式：</p>
<p><a href="https://api.weibo.com/oauth2/authorize?client_id=YOUR_CLIENT_ID&amp;response_type=code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI" target="_blank" rel="noopener">https://api.weibo.com/oauth2/authorize?client_id=YOUR_CLIENT_ID&amp;response_type=code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI</a></p>
</blockquote>
<p>访问我的授权地址：<a href="https://api.weibo.com/oauth2/authorize?client_id=547721421&amp;response_type=code&amp;redirect_uri=http://passport.gmall.com:8085/vlogin" target="_blank" rel="noopener">https://api.weibo.com/oauth2/authorize?client_id=547721421&amp;response_type=code&amp;redirect_uri=http://passport.gmall.com:8085/vlogin</a></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200301030616985.png" alt="image-20200301030616985"></p>
</li>
<li>
<p>通过回调地址获得授权码：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200301030520596.png" alt="image-20200301030520596"></p>
</li>
<li>
<p>用授权码code交换access_token（必须用post请求）</p>
<blockquote>
<p>授权码请求公式：</p>
<p><a href="https://api.weibo.com/oauth2/access_token?client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI&amp;code=CODE" target="_blank" rel="noopener">https://api.weibo.com/oauth2/access_token?client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI&amp;code=CODE</a></p>
</blockquote>
<p>由我的appKey和secretKey构造访问url，注意：授权码有时限会过期；每生成一次授权码，之前的作废；且授权码只能用一次，第二次再使用无效：</p>
<p><a href="https://api.weibo.com/oauth2/access_token?client_id=547721421&amp;client_secret=7f2d0d5edb88f273e22b6deac935d312&amp;grant_type=authorization_code&amp;redirect_uri=http://passport.gmall.com:8085/vlogin&amp;code=926cbd9352e5361a5302b8a9099e5f3f" target="_blank" rel="noopener">https://api.weibo.com/oauth2/access_token?client_id=547721421&amp;client_secret=7f2d0d5edb88f273e22b6deac935d312&amp;grant_type=authorization_code&amp;redirect_uri=http://passport.gmall.com:8085/vlogin&amp;code=926cbd9352e5361a5302b8a9099e5f3f</a></p>
<p>请求成功后将返回一个JSON字符串，将其转换成Map取得其中access_token、uid等字段</p>
</li>
<li>
<p>用access_token查询用户信息</p>
<p>参考渣浪开发文档：<a href="https://open.weibo.com/wiki/%E5%BE%AE%E5%8D%9AAPI" target="_blank" rel="noopener">https://open.weibo.com/wiki/%E5%BE%AE%E5%8D%9AAPI</a>、<a href="https://open.weibo.com/wiki/2/users/show" target="_blank" rel="noopener">https://open.weibo.com/wiki/2/users/show</a></p>
</li>
</ol>
<h5 id="社交登录和项目的整合"><a class="header-anchor" href="#社交登录和项目的整合">¶</a>社交登录和项目的整合</h5>
<ol>
<li>用户在passport认证中心准备登录时，可选择第三方登录，跳转到：<a href="https://api.weibo.com/oauth2/authorize?client_id=547721421&amp;response_type=code&amp;redirect_uri=http://passport.gmall.com:8085/vlogin%EF%BC%8C%E5%BC%95%E5%AF%BC%E7%94%A8%E6%88%B7%E8%BF%9B%E5%85%A5%E6%8E%88%E6%9D%83%E7%95%8C%E9%9D%A2" target="_blank" rel="noopener">https://api.weibo.com/oauth2/authorize?client_id=547721421&amp;response_type=code&amp;redirect_uri=http://passport.gmall.com:8085/vlogin，引导用户进入授权界面</a></li>
<li>用户在授权完成后，第三方网站将授权码写到回调地址请求中，我们通过回调地址接收授权码并写入数据库</li>
<li>通过授权码发送post请求到第三方网站，换取access_token:<a href="https://api.weibo.com/oauth2/access_token?client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI&amp;code=CODE%EF%BC%8C%E5%B0%86%E6%8D%A2%E5%8F%96%E6%9D%A5%E7%9A%84access_token%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E5%86%99%E5%85%A5%E5%88%B0%E6%9C%AC%E5%B9%B3%E5%8F%B0%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">https://api.weibo.com/oauth2/access_token?client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI&amp;code=CODE，将换取来的access_token和第三方平台用户相关信息写入到本平台用户数据库</a></li>
<li>在用户使用的过程中通过access_token用GET请求获取用户数据（第三方平台的用户数据）。<a href="https://api.weibo.com/2/users/show.json?access_token=XXXX&amp;uid=XXXXX%E3%80%82%E9%80%9A%E8%BF%87%E7%AC%AC%E4%B8%89%E6%96%B9%E7%A4%BE%E4%BA%A4%E7%99%BB%E5%BD%95%E7%9A%84%E7%94%A8%E6%88%B7%E5%9C%A8%E6%9C%AC%E7%BD%91%E7%AB%99%E7%9A%84%E4%BF%A1%E6%81%AF%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%A8%EF%BC%8C%E8%AF%A5%E7%94%A8%E6%88%B7%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%B9%B3%E5%8F%B0%E7%9A%84%E9%AB%98%E7%BA%A7%E5%88%AB%E5%8A%9F%E8%83%BD%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BF%A1%E6%81%AF%E8%A1%A5%E5%85%A8%E6%93%8D%E4%BD%9C%E7%94%9A%E8%87%B3%E5%AE%9E%E5%90%8D%E8%AE%A4%E8%AF%81%E3%80%82" target="_blank" rel="noopener">https://api.weibo.com/2/users/show.json?access_token=XXXX&amp;uid=XXXXX。通过第三方社交登录的用户在本网站的信息需要补全，该用户在使用本平台的高级别功能时，需要进行信息补全操作甚至实名认证。</a></li>
</ol>
<h4 id="代码实现：-v2"><a class="header-anchor" href="#代码实现：-v2">¶</a>代码实现：</h4>
<p>PassportController.java</p>
<pre><code class="language-java">@RequestMapping(&quot;vlogin&quot;)
    public String vlogin(String code,HttpServletRequest request){
        //授权码换取access_token
        String access_token_url=&quot;https://api.weibo.com/oauth2/access_token?&quot;;
        Map&lt;String,String&gt; paramMap=new HashMap&lt;&gt;();
        paramMap.put(&quot;client_id&quot;,&quot;547721421&quot;);
        paramMap.put(&quot;client_secret&quot;,&quot;7f2d0d5edb88f273e22b6deac935d312&quot;);
        paramMap.put(&quot;grant_type&quot;,&quot;authorization_code&quot;);
        paramMap.put(&quot;redirect_uri&quot;,&quot;http://passport.gmall.com:8085/vlogin&quot;);
        paramMap.put(&quot;code&quot;,code);
        String access_token_json = HttpclientUtil.doPost(access_token_url, paramMap);
        Map access_token_map=JSON.parseObject(access_token_json,Map.class);
        //access_token换取用户信息
        assert access_token_map != null;
        Long uid = Long.parseLong((String) access_token_map.get(&quot;uid&quot;));
        String access_token = (String) access_token_map.get(&quot;access_token&quot;);
        String query_user_url=&quot;https://api.weibo.com/2/users/show.json?access_token=&quot;
                +access_token+&quot;&amp;uid=&quot;+uid;
        String user_json=HttpclientUtil.doGet(query_user_url);
        Map user_map = JSON.parseObject(user_json, Map.class);
        //将用户信息保存到数据库，用户类型设置为微博用户
        assert user_map!=null;
        UmsMember umsMember=new UmsMember();
        umsMember.setSourceType(2);
        umsMember.setAccessCode(code);
        umsMember.setAccessToken(access_token);
        umsMember.setSourceUid(uid);
        umsMember.setNickname((String) user_map.get(&quot;screen_name&quot;));
        umsMember.setCity((String)user_map.get(&quot;location&quot;));
        umsMember.setGender(user_map.get(&quot;gender&quot;).equals(&quot;m&quot;)?(user_map.get(&quot;gender&quot;).equals(&quot;f&quot;)?2:1):0);
        UmsMember login = userService.loginOauthUser(umsMember);

        //生成jwt的token，并且重定向到首页，携带该token
        String token=makeToken(login,request);
        return &quot;redirect:http://search.gmall.com:8083/?token=&quot;+token;
    }

    /**
     * 为登录用户制作token
     * @param umsMember 登录用户信息
     * @return token
     */
    private String makeToken(UmsMember umsMember,HttpServletRequest request){
        String token=&quot;&quot;;
        if (umsMember!=null){
            //登录成功，用JWT制作token
            Map&lt;String,Object&gt; userMap=new HashMap&lt;&gt;();
            userMap.put(&quot;memberId&quot;,umsMember.getId());
            userMap.put(&quot;nickname&quot;,umsMember.getNickname());
            String ip=request.getHeader(&quot;x-forwarded-for&quot;);     //通过nginx转发的客户端ip
            if (StringUtils.isBlank(ip)){
                ip=request.getRemoteAddr();     //从request中获取ip
                if (StringUtils.isBlank(ip)){
                    ip=&quot;123.123.123.123&quot;;       //异常情况，不做过多拓展
                }
            }
            token = JwtUtil.encode(&quot;2019gmall&quot;, userMap, ip);
            //存入一份token到redis
            userService.addUserToken(token,umsMember.getId());
        }else {
            //登录失败
            token+=&quot;FAILED&quot;;
        }
        return token;
    }
</code></pre>
<p>UserServiceImpl.java:</p>
<pre><code class="language-java">/**
 * 添加社交登录用户信息
 * @param umsMember 社交登录用户
 */
@Override
public UmsMember loginOauthUser(UmsMember umsMember) {
    UmsMember check=new UmsMember();
    check.setSourceUid(umsMember.getSourceUid());
    check.setSourceType(umsMember.getSourceType());
    UmsMember exist = userMapper.selectOne(check);
    if (exist==null){
        //首次采用第三方平台账号登录
        userMapper.insertSelective(umsMember);
    }else {
        //已有该第三方账号记录
        Example example=new Example(UmsMember.class);
        example.createCriteria().andEqualTo(&quot;sourceUid&quot;,umsMember.getSourceUid())
            .andEqualTo(&quot;sourceType&quot;,umsMember.getSourceType());
        userMapper.updateByExampleSelective(umsMember,example);     //更新一下账号信息
    }
    return userMapper.selectOne(umsMember);     //返回完整的登录用户信息
}
</code></pre>
<h3 id="P203结算和订单"><a class="header-anchor" href="#P203结算和订单">¶</a>P203结算和订单</h3>
<h5 id="1-介绍-v3"><a class="header-anchor" href="#1-介绍-v3">¶</a>1.介绍</h5>
<ol>
<li>电商平台支持多个设备登录，一个设备上登录并不会将另一个设备挤下线</li>
<li>生成结算页并没有对后台数据库进行任何变更，原来购物车信息并没发生变化，也没有生成订单数据结构。只是把将要结算的商品数据整合展示出来，让用户确认送货清单和选择收获地址信息的页面</li>
<li>点击提交订单按钮时，后台的购物车数据结构被删除，生成了订单数据结构。</li>
</ol>
<h5 id="2-提交订单的业务"><a class="header-anchor" href="#2-提交订单的业务">¶</a>2.提交订单的业务</h5>
<ol>
<li>用户确认了自己的订单信息</li>
<li>用户选择收货地址</li>
<li>确认其他信息（支付方式、发票、优惠券、积分、折扣）</li>
</ol>
<h5 id="3-订单的安全"><a class="header-anchor" href="#3-订单的安全">¶</a>3.订单的安全</h5>
<ol>
<li>
<p>如何防止用户通过页面回退的方式重复提交一个订单</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200303221300631.png" alt="image-20200303221300631"></p>
<p>缓存中根据memberId生成交易码，在提交订单时检查交易码，然后销毁</p>
<p>user:${memberId}:tradeCode（K）：随机字符串（V）</p>
<p><strong>如何防止并发情况下一key多用——使用lua脚本在查询到该key时马上删除</strong></p>
<pre><code class="language-java">@Override
public String checkTradeCode(String memberId,String tradeCode) {
    Jedis jedis=null;
    try{
        jedis=redisUtil.getJedis();
        String tradeKey=&quot;user:&quot; + memberId + &quot;:tradeCode&quot;;
        //使用lua脚本在发现key的同时删除key，防止订单攻击
        String script=&quot;if redis.call('get',KEYS[1]) == ARGV[1] &quot; +
            &quot;then return redis.call('del',KEYS[1]) else return 0 end&quot;;
        Long eval=(Long) jedis.eval(script, Collections.singletonList(tradeKey),
                                    Collections.singletonList(tradeCode));
        if (eval!=null&amp;&amp;eval!=0){
            return &quot;success&quot;;
        }else return &quot;fail&quot;;
    }finally {
        assert jedis != null;
        jedis.close();
    }
}
</code></pre>
<h5 id="4-订单数据的提交"><a class="header-anchor" href="#4-订单数据的提交">¶</a>4.订单数据的提交</h5>
<ol>
<li>
<p>根据用户id获得要购买的商品列表(购物车),和总价格，为确保结算数据为最新数据不能采用当前页面的数据！</p>
</li>
<li>
<p>检验价格、库存（不替用户做决定）</p>
<ul>
<li>根据用户信息查询当前用户的购物车中的商品数据</li>
<li>循环将购物车中的商品对象封装成订单对象（订单详情）</li>
<li>每次循环一个商品时，校验当前商品的库存和价格是否符合购买需求</li>
</ul>
</li>
<li>
<p>将订单和订单详情写入数据库</p>
</li>
<li>
<p>删除购物车对应的商品</p>
</li>
<li>
<p>支付对接：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200305025408641.png" alt="image-20200305025408641"></p>
<ol>
<li>
<p>用户请求谷粒商城进行支付</p>
</li>
<li>
<p>谷粒商城返回用户一个跳转支付宝的连接（带着谷粒商城和支付宝合作的appId）</p>
</li>
<li>
<p>用户的浏览器和支付宝交互过程中的安全问题</p>
<p>非对称密钥加密（rsa）：两个超大质数乘积的因式分解不可逆原理</p>
<p>通过rsa非对称密钥生成的网络签名，可以用来验证请求发送者的身份信息</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="P221支付服务"><a class="header-anchor" href="#P221支付服务">¶</a>P221支付服务</h3>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/wps1.png" alt="img"></p>
<p><img src="C:%5CUsers%5CApollos%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200305165234145.png" alt="image-20200305165234145"></p>
<h4 id="支付宝对接步骤"><a class="header-anchor" href="#支付宝对接步骤">¶</a>支付宝对接步骤</h4>
<blockquote>
<p>Alipay文档：<a href="https://docs.open.alipay.com/270" target="_blank" rel="noopener">https://docs.open.alipay.com/270</a></p>
</blockquote>
<h5 id="和支付宝建立支付协议（企业级账号）"><a class="header-anchor" href="#和支付宝建立支付协议（企业级账号）">¶</a>和支付宝建立支付协议（企业级账号）</h5>
<p>​	具体参考课件文档</p>
<h5 id="下载和整合支付宝sdk"><a class="header-anchor" href="#下载和整合支付宝sdk">¶</a>下载和整合支付宝sdk</h5>
<p>​	支付宝已有maven仓库依赖，引入依赖即可：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.alipay.sdk/alipay-sdk-java --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;
    &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200305175614834.png" alt="image-20200305175614834"></p>
<p>然后设置配置文件和配置类：</p>
<p>首先在resource目录下创建配置文件alipay.properties:</p>
<pre><code class="language-properties"># 尚硅谷的支付宝服务配置

# 支付宝接口地址
alipay_url=https://openapi.alipay.com/gateway.do
# 企业（尚硅谷）与支付宝间签订合作伙伴协议后得到的app_id
app_id=2018020102122556
# 企业的私钥
app_private_key=MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCdQeknhM2rhiGAH6V0ljxn3rAWIdzduTEQuteTfwjnZtvMhQPuuN1b/88D5yMuaZhZNFeUdWb+SmtP9DAzAWWgnT13T0YhJcxP6txm7JBRrjadCRt+LOFxPiPQk5t9fH7yXjw9i4uMDsNJeTncrVZ/AZYrk0ESC9anJR8XeuBc3HE8T4fqlKKl35jlumIWrPbPNQhKGXaGcOnpiaXO9qYYUSP/tnrjNYXHOso0yBs4YTl+LLX2TJ12p3n/oX6HnL4zQgtN5k4QasHP7CIig1ngcVQGfWsMm4djI9KXNXvGLQPfMQEmyb71mM5OCdl1MtAc6OaIAymhSv2hOLNIuyodAgMBAAECggEAe05/P5mGm4QlKI2n8u8KlneqovASe1kG/BNFjkYB+VBR8OAr4TfbepPvAyRuFap+5xN/yMz14VcBJkRWtufVhEdHNxJV7w/wUIncIGhGEYYFFMVbZWhTrbQH6TiUp6TC9dCmc6vD1CKPRkFj+YGBXT0lPy3LzBa0TYNyCbszyhthrgkpuFYbB0R93IPvvBh5NJFXQytwNb2oVopC9AQWviqnZUZcT0eJ087dQ1WLPa6blBD8DP1PUq0Ldr6pgKfObFxIj8+87DlJznRfdEsbqZlS7jagdw5tLr71WJpctIGPqKpgvajfePP/lj3eY82BKQB+aTw0zmAiB05Yes4LgQKBgQDq3EiQR8J1MEN2rpiLt1WvDYYvKVUgOY7Od//fRPgaMBstbe4TzGBpR8E+z267bHAWLaWtHkfX6muFHn1x68ozEUWk/nZq0smWnuPdcy4E7Itbk36W2FF/rOZB7j5ddlC9byrxDSNgcf9/FA/CU+i5KVQpLYfsk2dvwomvu0aFVQKBgQCraXpxzMmsBx4127LsZDO5bxfxb6nqzyK4NPe0VaGiRg8oaCWczcLz1J5iRqC9QeEwsSt4XU1sYBMTcsFpA0apZpm3prH2HJRx/isNENesaHcihF0mMd0WxU3xyRvWSDeZV5A1Zy1ZEJ+p17DGwb2j+yo2uBrDNXBgBWEzXwiRqQKBgBdXFvsHtqKQzlOQHGbeLGy+KlSrheMy9Sc9s7cLkqB/oWPNZfifugEceW71jGqh5y29EZb3yGoDyPWsxwi4Rxr2H3a7Nyd8lT4bwkdyt+MTYvIR4WW6T7chhqyMsbP2GyYIUzsrdBWUnrCRXNOSJTGpksyY0sZHC+OGcMp/EQ4VAoGBAIISSVL/pm1+/UK7U1ukcced8JpKNLM0uVD1CJ50eHHOHgR4e0owrWYfioxisejLjBlJ6AWvL2g0w2T3qKKKVN2JOM4ulU5/w3l4+KwygqaWowizTogEQJPd5ta52ADTzjTzSD/t6nByd+YHAWLhc4lyt0bMj6pf68VBb8/upm75AoGAGAYz79IVHp9eppykufjNcWu6okkG8tZnzuyaWKW/CuKKBWMaTk0vcyQlfJfxIBccoQrBuYyXBdcpPuZ/ys2C25pNrkACuhIKNgnMc0floJoYEfJzetw/3cIimWu4NJzVQOaojaGA58oo2+fub43Xn25Jq4rvSVe3oLdb5xWkw5Q=
# 支付宝的公钥
alipay_public_key=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAhkZi6W0wn/prX+NIIF9ATb5Z8ReKK4hFYtBrweDfGHD1mNW7YIZY4G5hE7S2Sry8eFXlFgSlBWlJ4fVnDaK9MkVThpwE2H65ooVlK/wLuyPqovIVpMt/utva5Ayuzv7eQOWK45FdLDNDlK8QLoBko6SS+YbnWnf7a+mrf4NAS4UFClpfe8Byqe8XIraO2Cg4Ko5Y5schX39rOAH8GlLdgqQRYVQ2dCnkIQ+L+I4Cy9Mvw3rIkTwt3MBU+AqREXY4r5Bn6cmmX/9MAJbFqrofGiUAqG+qbjTcZAzgNPfuiD0zXgt/YYjMQMzck75BOmwnYOam2ajODUSQn8Xybsa7wQIDAQAB
# 同步回调地址 重定向地址本地浏览器
return_payment_url=http://payment.gmall.com:8087/alipay/callback/return
# 异步通知地址 必须是公网接口(webService)
notify_payment_url=http://60.205.215.91/alipay/callback/notify
return_order_url=http://order.gmall.com:8086/orderList
</code></pre>
<p>然后在项目的config目录下创建配置类读取配置文件：</p>
<pre><code class="language-java">import com.alipay.api.AlipayClient;
import com.alipay.api.DefaultAlipayClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@PropertySource(&quot;classpath:alipay.properties&quot;)
public class AlipayConfig {
    @Value(&quot;${alipay_url}&quot;)
    private String alipay_url;
    @Value(&quot;${app_private_key}&quot;)
    private String app_private_key;
    @Value(&quot;${app_id}&quot;)
    private String app_id;
    public final static String format=&quot;json&quot;;
    public final static String charset=&quot;utf-8&quot;;
    public final static String sign_type=&quot;RSA2&quot;;
    public static String return_payment_url;
    public static  String notify_payment_url;
    public static  String return_order_url;
    public static  String alipay_public_key;
    @Value(&quot;${alipay_public_key}&quot;)
    public   void setAlipay_public_key(String alipay_public_key) {
        AlipayConfig.alipay_public_key = alipay_public_key;
    }
    @Value(&quot;${return_payment_url}&quot;)
    public   void setReturn_url(String return_payment_url) {
        AlipayConfig.return_payment_url = return_payment_url;
    }
    @Value(&quot;${notify_payment_url}&quot;)
    public   void setNotify_url(String notify_payment_url) {
        AlipayConfig.notify_payment_url = notify_payment_url;
    }
    @Value(&quot;${return_order_url}&quot;)
    public   void setReturn_order_url(String return_order_url) {
        AlipayConfig.return_order_url = return_order_url;
    }
    @Bean
    public AlipayClient alipayClient(){
        AlipayClient alipayClient=new DefaultAlipayClient(alipay_url,app_id,app_private_key,format,charset, alipay_public_key,sign_type );
        return alipayClient;
    }
}
</code></pre>
<h5 id="开发对接程序"><a class="header-anchor" href="#开发对接程序">¶</a>开发对接程序</h5>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200305204856552.png" alt="image-20200305204856552"></p>
<p>具体可参考支付宝开发文档完成本部分</p>
<pre><code class="language-java">    /**
     * 前往支付宝付款
     * @param outTradeNo 订单号
     * @param totalAmount 订单总额
     * @return 支付页面
     */
    @RequestMapping(&quot;alipay/submit&quot;)
    @LoginRequired
    @ResponseBody
    public String alipay(String outTradeNo,BigDecimal totalAmount,HttpServletRequest request,ModelMap modelMap){
        //获得一个支付宝请求的客户端（不是链接，而是封装好了http请求的表单请求）
        String form=&quot;&quot;;
        AlipayTradePagePayRequest alipayRequest=new AlipayTradePagePayRequest();  //创建API对应的request
        alipayRequest.setReturnUrl(AlipayConfig.return_payment_url);    //同步回调地址
        alipayRequest.setNotifyUrl(AlipayConfig.notify_payment_url);    //异步通知地址
        Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); //必选请求参数
        map.put(&quot;out_trade_no&quot;,outTradeNo);     //订单号
        map.put(&quot;product_code&quot;,&quot;FAST_INSTANT_TRADE_PAY&quot;);   //支付宝签约产品码，固定
//            map.put(&quot;total_amount&quot;,totalAmount);      //订单总额
        map.put(&quot;total_amount&quot;,0.01);           //模拟订单总额
        map.put(&quot;subject&quot;,&quot;谷粒商城收款中心&quot;);     //订单描述
        String param= JSON.toJSONString(map);
        alipayRequest.setBizContent(param);
        try {
            form = alipayClient.pageExecute(alipayRequest).getBody();
            System.out.println(form);
        } catch (AlipayApiException e) {
            e.printStackTrace();
        }
        //生成并保存用户的支付信息
        OmsOrder omsOrder=orderService.getOrderByOutTradeNo(outTradeNo);
        PaymentInfo paymentInfo=new PaymentInfo();
        paymentInfo.setCreateTime(new Date());
        paymentInfo.setOrderId(omsOrder.getId());
        paymentInfo.setOrderSn(outTradeNo);
        paymentInfo.setTotalAmount(totalAmount);
        paymentInfo.setPaymentStatus(&quot;未付款&quot;);
        paymentInfo.setSubject(&quot;一笔新的订单&quot;);
        paymentService.savePaymentInfo(paymentInfo);

        //提交请求到支付宝
        return form;
    }
</code></pre>
<h5 id="完成对接的回调接口"><a class="header-anchor" href="#完成对接的回调接口">¶</a>完成对接的回调接口</h5>
<p>支付成功后回调函数（谷粒商城被支付宝调用的函数）</p>
<blockquote>
<p>回调参数：<a href="https://docs.open.alipay.com/270/105902/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/105902/</a></p>
</blockquote>
<p>分析：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200305234044203.png" alt="image-20200305234044203"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200305234259984.png" alt="image-20200305234259984"></p>
<p>其html如下:</p>
<pre><code class="language-html">&lt;form name=&quot;punchout_form&quot; method=&quot;post&quot; action=&quot;https://openapi.alipay.com/gateway.do?charset=utf-8&amp;method=alipay.trade.page.pay&amp;sign=WoMSBhBgoYx8fxg71rP6PLngIR%2FpHCz6AQMU2hb6Dj%2F6YNn51KXkFxcUy74bhPd3Ti61%2FnGDt5KNKnfOo25QT%2BLfLR7EybmkHoGzYrl%2FIbwomPFjXzx4jU2Z5WxbS8W5m7uMTLXWLelmYbmgcWD1rvfnul0S7MaqVay22iNpfa5sEkadcFF5l25ZMhmuzZc%2FGOheLR18CwwdDyaHQWXBz%2BV%2BwchYoJZR4h6fVcZnEHapEfCLxLHCRXD6hpEj3%2B%2FUGRTGgUCptWzPw8wmGqih2EPsGstiLnjsOVitf97g%2B0jSEfITi35ltNFGo18uabhie0IQiif1dNcTHZBrKElUSQ%3D%3D&amp;return_url=http%3A%2F%2Fpayment.gmall.com%3A8087%2Falipay%2Fcallback%2Freturn&amp;notify_url=http%3A%2F%2F60.205.215.91%2Falipay%2Fcallback%2Fnotify&amp;version=1.0&amp;app_id=2018020102122556&amp;sign_type=RSA2&amp;timestamp=2020-03-05+23%3A39%3A30&amp;alipay_sdk=alipay-sdk-java-dynamicVersionNo&amp;format=json&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;biz_content&quot; value=&quot;{&amp;quot;out_trade_no&amp;quot;:&amp;quot;gmall158339829580220200365165135&amp;quot;,&amp;quot;total_amount&amp;quot;:0.01,&amp;quot;subject&amp;quot;:&amp;quot;谷粒商城收款中心&amp;quot;,&amp;quot;product_code&amp;quot;:&amp;quot;FAST_INSTANT_TRADE_PAY&amp;quot;}&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;立即支付&quot; style=&quot;display:none&quot; &gt;
&lt;/form&gt;
&lt;script&gt;document.forms[0].submit();&lt;/script&gt;
</code></pre>
<p>从post表单中谷粒商城请求支付宝的url中，可看到其中谷粒商城的签名（sign）</p>
<pre><code class="language-txt">sign=WoMSBhBgoYx8fxg71rP6PLngIR%2FpHCz6AQMU2hb6Dj%2F6YNn51KXkFxcUy74bhPd3Ti61%2FnGDt5KNKnfOo25QT%2BLfLR7EybmkHoGzYrl%2FIbwomPFjXzx4jU2Z5WxbS8W5m7uMTLXWLelmYbmgcWD1rvfnul0S7MaqVay22iNpfa5sEkadcFF5l25ZMhmuzZc%2FGOheLR18CwwdDyaHQWXBz%2BV%2BwchYoJZR4h6fVcZnEHapEfCLxLHCRXD6hpEj3%2B%2FUGRTGgUCptWzPw8wmGqih2EPsGstiLnjsOVitf97g%2B0jSEfITi35ltNFGo18uabhie0IQiif1dNcTHZBrKElUSQ%3D%3D

支付宝将会对谷粒商城的签名进行验签（根据谷粒商城保存在支付宝上的公钥）
</code></pre>
<p>扫码付款：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200305234816136.png" alt="image-20200305234816136"></p>
<p>支付完成后回跳到商户地址：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200305234957971.png" alt="image-20200305234957971"></p>
<p>支付宝回调谷粒商城url为：</p>
<pre><code class="language-txt">https://unitradeprod.alipay.com/acq/cashierReturn.htm?sign=K1iSL1DZJcHKW4c2lsoAM4NPRPpBreqdGPhOp6e4L8MsYMlsLWgMBpvrvjvrsxL7ZpEYyRGW6MnpXeT%252Fg0pnE4ny&amp;outTradeNo=gmall158339829580220200365165135&amp;pid=2088921750292524&amp;type=1
</code></pre>
<p>可看到其中支付宝的签名（sign）</p>
<pre><code class="language-txt">K1iSL1DZJcHKW4c2lsoAM4NPRPpBreqdGPhOp6e4L8MsYMlsLWgMBpvrvjvrsxL7ZpEYyRGW6MnpXeT%252Fg0pnE4ny&amp;outTradeNo=gmall158339829580220200365165135

谷粒商城验签（根据支付宝保存在谷粒商城上的公钥）
</code></pre>
<pre><code class="language-java">    @RequestMapping(&quot;alipay/callback/return&quot;)
    @LoginRequired
    @ResponseBody
    public String alipayCallbackReturn(String outTradeNo,BigDecimal totalAmount,HttpServletRequest request,ModelMap modelMap){

        //回调请求中获取支付宝发来的参数
        String sign = request.getParameter(&quot;sign&quot;);
        String trade_no = request.getParameter(&quot;trade_no&quot;);
        String out_trade_no = request.getParameter(&quot;out_trade_no&quot;);
        String trade_status = request.getParameter(&quot;trade_status&quot;);
        String total_amount = request.getParameter(&quot;total_amount&quot;);
        String subject = request.getParameter(&quot;subject&quot;);
        String call_back_content = request.getQueryString();

        //通过支付宝的paramsMap进行验证，2.0版本的接口将paramMap参数去掉了，导致同步请求没法验签
        if (StringUtils.isNotBlank(sign)){
            //验签成功
            PaymentInfo paymentInfo=new PaymentInfo();
            paymentInfo.setOrderSn(out_trade_no);
            paymentInfo.setPaymentStatus(&quot;已支付&quot;);
            paymentInfo.setAlipayTradeNo(trade_no); //支付宝交易凭证号
            paymentInfo.setCallbackContent(call_back_content);  //回调请求字符串
            paymentInfo.setCallbackTime(new Date());
            //更新用户的支付状态为已付款
            paymentService.payUp(paymentInfo);
        }

        //支付成功后的系统服务：订单服务、库存服务、物流

        return &quot;finish&quot;;
    }
</code></pre>
<h5 id="如何验签："><a class="header-anchor" href="#如何验签：">¶</a>如何验签：</h5>
<p>​	首先下载验签工具：<img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306000226150.png" alt="image-20200306000226150"></p>
<blockquote>
<p>文档连接，到该链接下载密钥生成工具：<a href="https://docs.open.alipay.com/291/105971/" target="_blank" rel="noopener">https://docs.open.alipay.com/291/105971/</a></p>
</blockquote>
<p>下载完成，可用：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306001347442.png" alt="image-20200306001347442"></p>
<p>个人开发条件有限，无法完成异步回调功能。若有需求可参考文档</p>
<h3 id="P233分布式事务"><a class="header-anchor" href="#P233分布式事务">¶</a>P233分布式事务</h3>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306041603200.png" alt="image-20200306041603200"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306034721987.png" alt="image-20200306034721987"></p>
<p><strong>分布式事务</strong>：在集群、分布式环境下，如何保持数据的一致性：分布式环境下，有些业务需要并发地去处理，并发的服务不能服务于和自己业务不同的数据结构。不同服务的不同数据结构如何在一个行为操作中同时提交或回滚。</p>
<blockquote>
<p>微服务架构下的分布式事务解决方案：<a href="https://www.cnblogs.com/jiangyu666/p/8522547.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangyu666/p/8522547.html</a></p>
</blockquote>
<h5 id="解决方案介绍："><a class="header-anchor" href="#解决方案介绍：">¶</a>解决方案介绍：</h5>
<ol>
<li>
<p>xa协议下的两段式提交</p>
<p>在xa写一下，提交一个事务需要经过两个阶段：预备+提交<br>
弊端：性能太低</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306035725902.png" alt="image-20200306035725902"></p>
</li>
<li>
<p>xa两段式提交的 进阶版：tcc（try confirm cancel）</p>
<p>需要在业务层实现Try、Confirm、Cancel接口<br>
弊端：入侵性太强（为了实现分布式事务要将业务代码进行大改动）</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306035802327.png" alt="image-20200306035802327"></p>
</li>
<li>
<p>基于消息的，采取最终一致性策略的分布式事务（性能效率高，电商网站采用）：消息队列MQ</p>
<p>在一个事务正在进行的同时，发出消息给其他业务，如果消息发送失败或消息的执行失败，则回滚消息，重复执行<br>
反复执行失败后，记录失败信息，后期补充性处理<br>
在消息系统中开启事务，消息的事务是指，保障消息被正常消费，否则回滚的一种机制</p>
</li>
</ol>
<h5 id="消息队列中间件"><a class="header-anchor" href="#消息队列中间件">¶</a>消息队列中间件</h5>
<ol>
<li>ActiveMQ，由Apache开发，基于jms的接口规则</li>
<li>RabbitMQ，C开发，基于amqp协议</li>
<li>kafka，大数据的消息中间件</li>
</ol>
<h5 id="ActiveMQ的安装和整合"><a class="header-anchor" href="#ActiveMQ的安装和整合">¶</a>ActiveMQ的安装和整合</h5>
<p>解压对应压缩包，命令行来到bin目录下，输入：</p>
<pre><code class="language-sh">activemq start
</code></pre>
<p>activemq的配置文件有点像tomcat，可前往conf目录下的activemq.xml配置</p>
<p>整合：首先在gmall-service-util中引入依赖(为了服务的并发)：</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;
   &lt;exclusions&gt;
      &lt;exclusion&gt;
         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
         &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
      &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
   &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
   &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;
   &lt;version&gt;5.15.2&lt;/version&gt;
   &lt;exclusions&gt;
      &lt;exclusion&gt;
         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
         &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
      &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="消息队列的模式"><a class="header-anchor" href="#消息队列的模式">¶</a>消息队列的模式</h5>
<ol>
<li>
<p>点对点（Point to Point）</p>
<p>点对点的消息系统中，消息分发给一个单独的使用者。点对点消息往往与队列（javax.jms.Queue）关联，若希望发送的每个消息都会被成功处理的话需要P2P模式</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306173541130.png" alt="image-20200306173541130"></p>
<p>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</p>
<p>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</p>
<p>接收者在成功接收消息之后需向队列应答成功</p>
</li>
<li>
<p>发布、订阅模式（Topic）</p>
<p>发布/订阅消息系统支持一个事件驱动模型，消息生产者和消费者都参与消息的传递。生产者发布事件，而使用者订阅感兴趣的事件，并使用事件。该类型消息一般与特定的主题（javax.jms.Topic）关联。<strong>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</strong></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306174039980.png" alt="image-20200306174039980"></p>
<ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li>
<li>为了消费消息，订阅者必须保持运行的状态</li>
</ul>
</li>
<li>
<p>测试</p>
<p>我们暂时在gmall-payment里新建test目录，复制如下测试代码<br>
P2P模式生产者：TestMqProducer.java</p>
<pre><code class="language-java"></code></pre>
</li>
</ol>
<p>public static void main(String[] args) {</p>
<pre><code>   ConnectionFactory connect = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);
   try {
       Connection connection = connect.createConnection();
       connection.start();
       //第一个值表示是否使用事务，如果选择true，第二个值相当于选择0
       Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
    Queue testqueue = session.createQueue(&quot;drink&quot;);

       MessageProducer producer = session.createProducer(testqueue);
       TextMessage textMessage=new ActiveMQTextMessage();
       textMessage.setText(&quot;谁帮我卢本伟倒一杯卡布奇诺？&quot;);
       producer.setDeliveryMode(DeliveryMode.PERSISTENT);
       producer.send(textMessage);
       session.commit();
       connection.close();
    System.out.println(&quot;我卢本伟下线了&quot;);

   } catch (JMSException e) {
       e.printStackTrace();
}

}
```
</code></pre>
<pre><code>   
P2P模式消费者：TestMqConsumer.java
   
​```java
   public static void main(String[] args) {
       ConnectionFactory connect = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER,ActiveMQConnection.DEFAULT_PASSWORD,&quot;tcp://localhost:61616&quot;);
       try {
           Connection connection = connect.createConnection();
           connection.start();
           //第一个值表示是否使用事务，如果选择true，第二个值相当于选择0
           Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
           Destination testqueue = session.createQueue(&quot;drink&quot;);
   
           MessageConsumer consumer = session.createConsumer(testqueue);
           consumer.setMessageListener(new MessageListener() {
               @Override
               public void onMessage(Message message) {
                   if(message instanceof TextMessage){
                       try {
                           String text = ((TextMessage) message).getText();
                           System.out.println(text+&quot;\t我来帮你，我是线程:&quot;+Thread.currentThread().getName());
                           //session.rollback();
                       } catch (JMSException e) {
                           e.printStackTrace();
                       }
                   }
               }
           });
       }catch (Exception e){
           e.printStackTrace();;
       }
   }
</code></pre>
<p>可看到运行效果：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306180722248.png" alt="image-20200306180722248"></p>
<p>provider发出消息后即可关闭连接，而consumer一直处于监听状态。可在后台查看目前消息队列情况：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306180859902.png" alt="image-20200306180859902"></p>
<p>另外：<strong>点对点模式允许多个消费者</strong>，但一条消息只能被一个消费者消费。多个消费者情况下，<strong>消费者们将以轮询的方式消费消息</strong></p>
<p>Topic模式生产者，将createProducer的参数换成Topic即可：</p>
<pre><code class="language-java">Connection connection = connect.createConnection();
connection.start();
//第一个值表示是否使用事务，如果选择true，第二个值相当于选择0
Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
//话题模式消息
Topic t=session.createTopic(&quot;speaking&quot;);
MessageProducer producer = session.createProducer(t);
TextMessage textMessage=new ActiveMQTextMessage();
textMessage.setText(&quot;快多点来人帮我扛两百斤麦子！&quot;);
producer.setDeliveryMode(DeliveryMode.PERSISTENT);
producer.send(textMessage);
session.commit();
connection.close();
</code></pre>
<p>Topic模式消费者，将session.createQueue改为session.createTopic：</p>
<pre><code class="language-java">Destination topic = session.createTopic(&quot;speaking&quot;);
MessageConsumer consumer = session.createConsumer(topic);
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306201315877.png" alt="image-20200306201315877"></p>
<p>先开启三个consumer，再开启一个producer，producer发出的topic将同时被三个consumer消费</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306201507395.png" alt="image-20200306201507395"></p>
<p>topic模式消息无法持久化，若发出时没有消费者，就没了。它不像队列消息能记录消息状态。</p>
<p>队列模式的消息在消息本身记录消息状态，话题模式消息由消费者记录消息状态（想要持久化的话在消费者客户端进行）</p>
<ol start="4">
<li>
<p>事务控制：</p>
<table>
<thead>
<tr>
<th>producer提交时的事务</th>
<th style="text-align:left">事务开启</th>
<th>只执行send并不会提交到队列中，只有当执行session.commit()时，消息才被真正的提交到队列中。</th>
</tr>
</thead>
<tbody>
<tr>
<td>↑</td>
<td style="text-align:left">事务不开启</td>
<td>只要执行send，就进入到队列中。</td>
</tr>
<tr>
<td>consumer 接收时的事务</td>
<td style="text-align:left">事务开启，签收必须写Session.SESSION_TRANSACTED</td>
<td>收到消息后，消息并没有真正的被消费。消息只是<strong>被锁住。一旦出现该线程死掉、抛异常，或者程序执行了session.rollback()那么消息会释放，重新回到队列中被别的消费端再次消费。</strong></td>
</tr>
<tr>
<td>↑</td>
<td style="text-align:left">事务不开启，签收方式选择Session.AUTO_ACKNOWLEDGE</td>
<td>只要调用comsumer.receive方法 ，<strong>自动确认</strong>。</td>
</tr>
<tr>
<td>↑</td>
<td style="text-align:left">事务不开启，签收方式选择Session.CLIENT_ACKNOWLEDGE</td>
<td>需要客户端执行 message.acknowledge(),否则视为未提交状态，线程结束后，其他线程还可以接收到。 这种方式跟事务模式很像，区别是不能手动回滚,而且可以单独确认某个消息。</td>
</tr>
<tr>
<td>↑</td>
<td style="text-align:left">事务不开启，签收方式选择Session.DUPS_OK_ACKNOWLEDGE</td>
<td>在Topic模式下做批量签收时用的，可以提高性能。但是某些情况消息可能会被重复提交，使用这种模式的consumer要可以处理重复提交的问题。</td>
</tr>
</tbody>
</table>
<p><strong>持久化</strong>：通过<strong>producer.setDeliveryMode(DeliveryMode.PERSISTENT)</strong> 进行设置。持久化的好处就是当activemq宕机的话，消息队列中的消息不会丢失。非持久化会丢失。但是会消耗一定的性能。</p>
</li>
</ol>
<h5 id="mq整合Spring"><a class="header-anchor" href="#mq整合Spring">¶</a>mq整合Spring</h5>
<ol>
<li>
<p>编写mq工厂</p>
<pre><code class="language-java">public class ActiveMQUtil {
    PooledConnectionFactory pooledConnectionFactory=null;

    public ConnectionFactory init(String brokerUrl) {
        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(brokerUrl);
         //加入连接池
        pooledConnectionFactory=new PooledConnectionFactory(factory);
        //出现异常时重新连接
        pooledConnectionFactory.setReconnectOnException(true);
        //
        pooledConnectionFactory.setMaxConnections(5);
        pooledConnectionFactory.setExpiryTimeout(10000);
        return pooledConnectionFactory;
    }

    public ConnectionFactory getConnectionFactory(){
        return pooledConnectionFactory;
    }
}
</code></pre>
</li>
<li>
<p>将mq工厂初始化到spring容器中:</p>
<pre><code class="language-java">@Configuration
public class ActiveMQConfig {
    @Value(&quot;${spring.activemq.broker-url:disabled}&quot;)
    String brokerURL ;
    @Value(&quot;${activemq.listener.enable:disabled}&quot;)
    String listenerEnable;
    @Bean
    public    ActiveMQUtil   getActiveMQUtil() throws JMSException {
        if(brokerURL.equals(&quot;disabled&quot;)){
            return null;
        }
        ActiveMQUtil activeMQUtil=new ActiveMQUtil();
        activeMQUtil.init(brokerURL);
        return  activeMQUtil;
    }
    //定义一个消息监听器连接工厂，这里定义的是点对点模式的监听器连接工厂
    @Bean(name = &quot;jmsQueueListener&quot;)
    public DefaultJmsListenerContainerFactory jmsQueueListenerContainerFactory(ActiveMQConnectionFactory activeMQConnectionFactory ) {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        if(!listenerEnable.equals(&quot;true&quot;)){
            return null;
        }

        factory.setConnectionFactory(activeMQConnectionFactory);
        //设置并发数
        factory.setConcurrency(&quot;5&quot;);

        //重连间隔时间
       factory.setRecoveryInterval(5000L);
       factory.setSessionTransacted(false);
       factory.setSessionAcknowledgeMode(Session.CLIENT_ACKNOWLEDGE);

        return factory;
    }
    @Bean
    public ActiveMQConnectionFactory activeMQConnectionFactory ( ){
/*        if((url==null||url.equals(&quot;&quot;))&amp;&amp;!brokerURL.equals(&quot;disabled&quot;)){
            url=brokerURL;
        }*/
        ActiveMQConnectionFactory activeMQConnectionFactory =
                new ActiveMQConnectionFactory(  brokerURL);
        return activeMQConnectionFactory;
    }
}
</code></pre>
<p>注意application.properties中添加配置：</p>
<pre><code class="language-properties"># ActiveMQ消息端口，tcp协议
spring.activemq.broker-url=tcp://localhost:61616
# 开启监听
activemq.listener.enable=true
</code></pre>
<p>测试一下是否整合成功：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306210322637.png" alt="image-20200306210322637"></p>
</li>
<li>
<p>将mq的监听器封装到spring容器中</p>
</li>
</ol>
<h5 id="5-分布式事务的业务模型"><a class="header-anchor" href="#5-分布式事务的业务模型">¶</a>5.分布式事务的业务模型</h5>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200306223641235.png" alt="image-20200306223641235"></p>
<ol start="0">
<li>
<p>提交订单的延迟检查（支付服务）：PAYMENT_CHECK_QUEUE</p>
</li>
<li>
<p>支付完成（支付服务）：PAYMENT_SUCCESS_QUEUE</p>
</li>
<li>
<p>订单已支付（订单服务）：ORDER_PAY_QUEUE</p>
</li>
<li>
<p>库存锁定（库存系统）：SKU_DEDUCT_QUEUE</p>
</li>
<li>
<p>订单已出库（订单服务）：ORDER_SUCCESS_QUEUE</p>
<p>其他：购物车合并队列、商品管理的同步队列</p>
</li>
</ol>
<h3 id="P248延迟队列"><a class="header-anchor" href="#P248延迟队列">¶</a>P248延迟队列</h3>
<h5 id="1-延迟队列解决的问题"><a class="header-anchor" href="#1-延迟队列解决的问题">¶</a>1.延迟队列解决的问题</h5>
<p><strong>如果支付宝页面支付成功后就立即关闭页面，那么就无法进行回跳到商城提供的支付成功回调地址，进而导致请求回调地址时触发的更新支付状态逻辑无法被执行，商城后台无法更新订单状态。</strong></p>
<p>定时任务：在提交支付后，向消息队列发送一个延迟执行的消息任务，当该任务被支付服务执行时，在消费任务的程序中去查询当前交易的交易状态，根据交易状态（支付结束）决定解除延迟任务还是继续设置新的延迟任务。</p>
<p>配置消息队列的延迟属性：MQ的conf目录下activemq.xml中，在broker那一行新增：schedulerSupport=true</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200307004548247.png" alt="image-20200307004548247"></p>
<h5 id="2-消费延迟队列（支付服务）："><a class="header-anchor" href="#2-消费延迟队列（支付服务）：">¶</a>2. 消费延迟队列（支付服务）：</h5>
<p>检查当前订单的交易状态，根据交易状态（没有成功支付），设置重新发送延迟检查的时间和队列<br>
检查当前订单的交易状态，根据交易状态（支付成功），更新支付信息发送订单队列（幂等性检查）</p>
<p>查询接口：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200307050901873.png" alt="image-20200307050901873"></p>
<p>在支付服务的m消费端PaymentServiceMqListener 调用阿里的支付查询接口(通过paymentService)<br>
（特殊可选：必选其一）：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200307052231829.png" alt="image-20200307052231829"></p>
<ol>
<li>
<p>需要有延迟检查的限制</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200307173247396.png" alt="image-20200307173247396"></p>
<p>不能无限循环检查，需要加入检查次数限制，满N结束检查</p>
</li>
<li>
<p>检查支付情况的接口</p>
<p>调用支付宝订单查询的API，将返回如下支付情况查询结果：</p>
<ul>
<li>
<p>交易未创建</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200307174536656.png" alt="image-20200307174536656"></p>
</li>
<li>
<p>交易已创建但未支付</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200307174323245.png" alt="image-20200307174323245"></p>
</li>
<li>
<p>交易成功</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200307174737355.png" alt="image-20200307174737355"></p>
<p>根据查询结果对消息队列做相应处理：</p>
<p>PaymentServiceImpl.java:</p>
<pre><code class="language-java">@Override
public Map&lt;String, Object&gt; checkAlipayPayment(String out_trade_no) {
    Map&lt;String,Object&gt; resultMap=new HashMap&lt;&gt;();

    AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
    Map&lt;String,Object&gt; requestMap=new HashMap&lt;&gt;();
    requestMap.put(&quot;out_trade_no&quot;,out_trade_no);
    request.setBizContent(JSON.toJSONString(requestMap));
    AlipayTradeQueryResponse response = null;
    try {
        response = alipayClient.execute(request);
    } catch (AlipayApiException e) {
        e.printStackTrace();
    }
    if(response.isSuccess()){
        System.out.println(&quot;调用支付宝服务接口查询交易结果，交易可能创建成功&quot;);
        resultMap.put(&quot;out_trade_no&quot;,response.getOutTradeNo());
        resultMap.put(&quot;trade_no&quot;,response.getTradeNo());
        resultMap.put(&quot;trade_status&quot;,response.getTradeStatus());
    } else {
        System.out.println(&quot;调用支付宝服务接口查询交易结果，交易可能失败&quot;);
    }
    return resultMap;
}
</code></pre>
<p>PaymentServiceMqListener.java:</p>
<pre><code class="language-java">@JmsListener(destination = &quot;PAYMENT_CHECK_QUEUE&quot;,containerFactory = &quot;jmsQueueListener&quot;)
public void paymentCheckResultConsumer(MapMessage mapMessage) throws JMSException {
    String out_trade_no = mapMessage.getString(&quot;out_trade_no&quot;);
    int count= mapMessage.getInt(&quot;count&quot;); //剩余检查次数
    //调用支付宝检查接口
    Map&lt;String,Object&gt; resultMap=paymentService.checkAlipayPayment(out_trade_no);

    if (resultMap!=null&amp;&amp;!resultMap.isEmpty()){
        String trade_status=(String) resultMap.get(&quot;trade_status&quot;);
        if (StringUtils.isNotBlank(trade_status)&amp;&amp;
            trade_status.equals(&quot;TRADE_SUCCESS&quot;)){
            //paymentService.payUp(null);
            System.out.println(&quot;支付成功，调用支付服务，修改支付信息和发送支付成功的队列&quot;);
            return;
        }
    }
    //继续发送延迟检查任务，计算延迟时间等
    if (count&gt;0){
        //继续发送延迟检查任务，计算延迟时间等
        System.out.println(&quot;没支付成功，继续发送延迟检查消息，还剩检查次数：&quot;+count);
        count--;
        paymentService.sendDelayPaymentResultCheckQueue(out_trade_no,count);
    }else {
        System.out.println(&quot;检查次数用尽，放弃检查&quot;);
    }
}
</code></pre>
</li>
</ul>
</li>
</ol>
<h5 id="3-幂等性问题"><a class="header-anchor" href="#3-幂等性问题">¶</a>3.幂等性问题</h5>
<p>​	幂等性：服务器对于相同的一次或多次请求，所返回的状态结果应该是一致的。</p>
<h5 id="4-库存系统的介绍："><a class="header-anchor" href="#4-库存系统的介绍：">¶</a>4. 库存系统的介绍：</h5>
<ol>
<li>
<p>库存表</p>
<p>wms_ware_info，库存信息表</p>
</li>
<li>
<p>库存系统和商品（sku）的对应关系表</p>
<p>wms_ware_sku，库存中的商品与电商平台商品对应关系表：多对多的关系</p>
</li>
<li>
<p>wms_ware_order_task</p>
<p>库存根据订单的库存情况，对订单拆分的结果（一个订单的多项商品分别在不同的仓库，故该订单需拆分以便从多个仓库取货）</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200307225524566.png" alt="image-20200307225524566"></p>
</li>
<li>
<p>wms_ware_order_task_detail：拆单所得的子订单中的商品详情</p>
</li>
<li>
<p>拆单因素：商家、库存、商品类型、价格、物流等其他因素</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200307230401041.png" alt="image-20200307230401041"></p>
</li>
</ol>
<h3 id="P259基本完成，一些问题的补充"><a class="header-anchor" href="#P259基本完成，一些问题的补充">¶</a>P259基本完成，一些问题的补充</h3>
<ol>
<li>
<p>在商品后台管理中，发布商品SKU时应当用消息队列发出商品的同步消息，同步缓存（在SkuService里实现）及搜索引擎（在SearchService里实现）。</p>
</li>
<li>
<p>搜索热度问题：搜索商品时，热度值字段需要更新。但在ES搜索的同时更新热度值（ES将会更新索引，但ES并不是内存数据库，会做相应的读写IO操作，十分影响性能；修改某一个值在高并发的情况下会有冲突，造成更新的丢失，需要枷锁，而es的乐观锁会恶化性能问题）会给服务器造成非常大的压力。</p>
<p>我们可以把热度值字段单独存储在redis中。在redis中专门放置一个与es中对应的热度值字段，es搜索后，根据搜索结果商品的id，取出热度值字段，再依次对搜索结果进行排序。</p>
<p>用es做精确计数器，redis是内存数据库有强大的读写性能，利用redis原子性的自增可解决并发写操作问题。redis每100次技术我们就更新一次es，这样就能将es的写操作稀释100倍，这个倍数可根据业务需求灵活设定。</p>
</li>
<li>
<p>购物车模块，用户登录时应当合并Cookie和db中的购物车数据，并且同步redis。当时避免服务串行而没实现（这样会让登录和购物车功能的耦合，购物车会影响到登录功能）</p>
<p>解决：在用户登录时发出用户登录的消息（话题消息topic），让cartService消费，做购物车的合并及同步缓存。</p>
<p>在访问购物车列表时，如果当前用户已登录，则删除cookie中多余的购物车数据。</p>
</li>
<li>
<p>库存与订单数据不一致问题：提交订单时，商品可能已经发生库存的变动（被买走，库存被锁定）</p>
<p>解决：调用库存服务的库存查询接口，作库存的校验</p>
</li>
<li>
<p>库存削减的队列（SKU_DEDUCT_QUEUE）</p>
<p>由订单服务消费，订单服务修改订单状态为准备出库</p>
</li>
</ol>
<h3 id="P260秒杀和限流"><a class="header-anchor" href="#P260秒杀和限流">¶</a>P260秒杀和限流</h3>
<p>服务器容量：一台或多台服务器最多能够承载的当前的连接数，也就是所能装的session总数量。若当前最大连接数10w，连接数已满，为防止下一个人连接我们可以用servlet的sessionListener监听session上限。</p>
<p>服务器流量：某单位时间内的接收或处理请求的数量（吞吐量），</p>
<h4 id="秒杀"><a class="header-anchor" href="#秒杀">¶</a>秒杀</h4>
<p>基于redis解决</p>
<ol>
<li>
<p>缓存秒杀模型：</p>
<p>redis是单线程的，所以在redis中所有命令都是原子操作。而当要多条redis命令同时执行而不被打断时，则需要使用redis的事务了。</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200308030042315.png" alt="image-20200308030042315"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200308031414228.png" alt="image-20200308031414228"></p>
</li>
<li>
<p>新建秒杀项目Demo：gmall-seckill</p>
<p>​	引入依赖：gmall-parent、gmall-api、gmall-web-util、gmall-service-util</p>
<ul>
<li>基于redis的简易秒杀：</li>
</ul>
<p>利用redis的incrBy写数据。先写个简单的请求响应试试：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200308171318881.png" alt="image-20200308171318881"></p>
<p>用Apache进行一下简单的压力测试：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200308171945995.png" alt="image-20200308171945995"></p>
<p>再用两百条请求模拟一下，这次抢购前先打印剩余库存数：</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200308173113839.png" alt="image-20200308173113839"></p>
<blockquote>
<p>MULTI命令 ：</p>
<p>用于开启一个事务，它总是返回OK。MULTI执行之后,客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行，而是被放到一个队列中，当 EXEC命令被调用时， 所有队列中的命令才会被执行。</p>
<p>EXEC命令 ：</p>
<p>负责触发并执行事务中的所有命令。如果客户端成功开启事务后执行EXEC，那么事务中的所有命令都会被执行。 如果客户端在使用MULTI开启了事务后，却因为断线而没有成功执行EXEC,那么事务中的所有命令都不会被执行。<br>
需要特别注意的是：即使事务中有某条/某些命令执行失败了，事务队列中的其他命令仍然会继续执行——Redis不会停止执行事务中的命令，而不会像我们通常使用的关系型数据库一样进行回滚。</p>
<p>DISCARD命令 ：</p>
<p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空，并且客户端会从事务状态中退出。</p>
<p>WATCH 命令</p>
<p>可以为Redis事务提供 check-and-set （CAS）行为。被WATCH的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。</p>
</blockquote>
<pre><code class="language-java">// 加入watch与multi命令，解决并发问题
Jedis jedis=redisUtil.getJedis();
jedis.watch(&quot;122&quot;);
int stock=Integer.parseInt(jedis.get(&quot;122&quot;));
if (stock&gt;0){
    Transaction multi = jedis.multi();
    multi.incrBy(&quot;122&quot;,-1);
    List&lt;Object&gt; exec = multi.exec();
    if (exec!=null&amp;&amp;exec.size()&gt;0){
        System.out.println(&quot;当前库存剩余数量：&quot;+stock+
                           &quot;,某某用户抢购成功。当前抢购人数：&quot;+(1000-stock));
    }else {
        System.out.println(&quot;当前库存剩余数量：&quot;+stock+
                           &quot;,某某用户抢购失败&quot;);
    }
}
jedis.close();
</code></pre>
<p>10k条请求，并发量为10进行测试，结果正常，并发问题基本得以解决</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200309014524720.png" alt="image-20200309014524720"></p>
<p>watch的不足在于，并发情况下若抢购失败就真的失败了，不能排队继续等待。抢购的成功与否与抢购瞬间并发量有关，与先下手和后下手无关。属于随机拼运气形式的秒杀</p>
<ul>
<li>基于redission的秒杀</li>
</ul>
<pre><code class="language-java">@RequestMapping(&quot;/seckill&quot;)
@ResponseBody
public String seckill(){
    Jedis jedis = redisUtil.getJedis();
    RSemaphore semaphore = redissonClient.getSemaphore(&quot;122&quot;);
    boolean b = semaphore.tryAcquire();
    if (b){
        int stock = Integer.parseInt(jedis.get(&quot;122&quot;));
        System.out.println(&quot;当前库存剩余数量：&quot;+stock+
                           &quot;,某某用户抢购成功。当前抢购人数：&quot;+(1000-stock));
        //消息队列发出订单消息
    }else {
        int stock = Integer.parseInt(jedis.get(&quot;122&quot;));
        System.out.println(&quot;当前库存剩余数量：&quot;+stock+
                           &quot;,某某用户抢购失败&quot;);
    }
    jedis.close();
    return &quot;1&quot;;
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200309023540790.png" alt="image-20200309023540790"></p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200309024139594.png" alt="image-20200309024139594"></p>
<p>redission采用了信号量的机制，可做到手快有手慢无的秒杀实现。</p>
</li>
</ol>
<h4 id="限流"><a class="header-anchor" href="#限流">¶</a>限流</h4>
<p>服务器容量：一台或多台服务器最多能够承载的当前的连接数，也就是所能装的session总数量。若当前最大连接数10w，连接数已满，为防止下一个人连接我们可以用servlet的sessionListener监听session上限。</p>
<p>服务器流量：某单位时间内的接收或处理请求的数量（吞吐量）</p>
<p>限流一般在Nginx中进行，用lua脚本去写</p>
<p>限流方案：</p>
<ol>
<li>
<p>按秒计算服务器请求是否达到最大值（如1w请求），超过最大值则拒绝请求</p>
<p>缺点：所计算时间内，第999ms和第1002ms之间突然打来1w条请求，该方法失效</p>
</li>
<li>
<p>漏桶算法：</p>
<p>漏桶算法很好的解决了时间边界处理不够平滑的问题，在每次请求进桶前都将执行“漏水”的操作，然后再计算当前水量，即不以时间为界限，而以流量为界限进行计算，回避了时间边界的问题。</p>
<pre><code class="language-java">/*****伪代码*****/
long timeStamp = getNowTime(); 
int capacity = 10000;// 桶的容量，即最大承载值
int rate = 1;//水漏出的速度，即服务器的处理请求的能力
int water = 100;//当前水量，即当前的即时请求压力

//当前请求线程进入漏桶方法，true则不被拒绝，false则说明当前服务器负载水量不足，则被拒绝
public static bool control() {
long  now = getNowTime();//当前请求时间
//先执行漏水代码
//rate是固定的代表服务器的处理能力，所以可以认为“时间间隔*rate”即为漏出的水量
    water = Math.max(0, water - (now - timeStamp) * rate);//请求时间-上次请求时间=时间间隔
    timeStamp = now;//更新时间，为下次请求计算间隔做准备
    if (water &lt; capacity) { 
        // 执行漏水代码后，发现漏桶未满，则可以继续加水，即没有到服务器可以承担的上线
        water ++; 
        return true; 
    } else { 
        return false;//水满，拒绝加水，到服务器可以承担的上线，拒绝请求
   } 
}
</code></pre>
</li>
<li>
<p>令牌桶算法</p>
<p>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。</p>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200309031713936.png" alt="image-20200309031713936"></p>
<p>从桶里拿了门票令牌才能进</p>
<pre><code class="language-java">/********伪代码********/
long timeStamp=getNowTime(); 
int capacity; // 桶的容量 
int rate ;//令牌放入速度
int tokens;//当前水量  

bool control() {
   //先执行添加令牌的操作
   long  now = getNowTime();
   tokens = max(capacity, tokens+ (now - timeStamp)*rate); 
   timeStamp = now;  
   if(tokens&lt;1){
     return false; //令牌已用完，拒绝访问
   }else{ 
     tokens--;
     retun true; //还有令牌，领取令牌
   }
 }
</code></pre>
</li>
</ol>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<p><img src="https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/img_%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/image-20200309032519942.png" alt="image-20200309032519942"></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 708801794@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>谷粒商城项目学习笔记</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">29.4k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="梅罢葛">梅罢葛</a></p>
    <p><span class="copy-title">发布时间:</span>2020-03-28, 01:16:39</p>
    <p><span class="copy-title">最后更新:</span>2020-04-26, 23:34:35</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/03/28/SpringBoot_%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" title="谷粒商城项目学习笔记">https://qiurungeng.github.io/2020/03/28/SpringBoot_%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/</a>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2020 梅罢葛</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#Linux','#MySQL','#前端','#java','#jvm','#算法','#数据结构','#Java','#socket编程','#Netty','#SpringBoot','#spring','#spring注解','#AOP','#spring-InstantiationAwareBeanPostProcessor','#动态规划','#LeetCode','#剑指Offer','#测试','#操作系统','#设计模式','#NIO','#分布式','#后端','#计算机网络',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 552px;
    }
    .nav.fullscreen {
        margin-left: -552px;
    }
    .nav-left {
        width: 130px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    .post {
        background: url(https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/20200329232512.png);
    }
    
    
    .post.index {
        background: url(https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/20200329232512.png);
    }
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.4;
        background: url("https://raw.githubusercontent.com/WinstonSmith1989/mymarkdownpics/master/img/%E5%A4%A7%E6%B4%AA%E6%B0%B4.jpg");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
